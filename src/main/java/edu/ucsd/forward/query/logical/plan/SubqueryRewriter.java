package edu.ucsd.forward.query.logical.plan;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import edu.ucsd.app2you.util.logger.Logger;
import edu.ucsd.forward.data.type.TupleType;
import edu.ucsd.forward.data.value.IntegerValue;
import edu.ucsd.forward.data.value.StringValue;
import edu.ucsd.forward.query.QueryCompilationException;
import edu.ucsd.forward.query.function.AbstractFunctionCall;
import edu.ucsd.forward.query.function.aggregate.AggregateFunctionCall;
import edu.ucsd.forward.query.function.tuple.TupleFunctionCall;
import edu.ucsd.forward.query.logical.AntiSemiJoin;
import edu.ucsd.forward.query.logical.ApplyPlan;
import edu.ucsd.forward.query.logical.Assign;
import edu.ucsd.forward.query.logical.Copy;
import edu.ucsd.forward.query.logical.EliminateDuplicates;
import edu.ucsd.forward.query.logical.Exists;
import edu.ucsd.forward.query.logical.Ground;
import edu.ucsd.forward.query.logical.GroupBy;
import edu.ucsd.forward.query.logical.GroupBy.Aggregate;
import edu.ucsd.forward.query.logical.GroupBy.Item;
import edu.ucsd.forward.query.logical.IndexScan;
import edu.ucsd.forward.query.logical.InnerJoin;
import edu.ucsd.forward.query.logical.Navigate;
import edu.ucsd.forward.query.logical.OffsetFetch;
import edu.ucsd.forward.query.logical.Operator;
import edu.ucsd.forward.query.logical.OuterJoin;
import edu.ucsd.forward.query.logical.PartitionBy;
import edu.ucsd.forward.query.logical.Product;
import edu.ucsd.forward.query.logical.Project;
import edu.ucsd.forward.query.logical.Scan;
import edu.ucsd.forward.query.logical.Select;
import edu.ucsd.forward.query.logical.SemiJoin;
import edu.ucsd.forward.query.logical.SendPlan;
import edu.ucsd.forward.query.logical.SetOperator;
import edu.ucsd.forward.query.logical.Sort;
import edu.ucsd.forward.query.logical.Subquery;
import edu.ucsd.forward.query.logical.ddl.CreateDataObject;
import edu.ucsd.forward.query.logical.ddl.DropDataObject;
import edu.ucsd.forward.query.logical.dml.Delete;
import edu.ucsd.forward.query.logical.dml.Insert;
import edu.ucsd.forward.query.logical.dml.Update;
import edu.ucsd.forward.query.logical.dml.Update.Assignment;
import edu.ucsd.forward.query.logical.term.Constant;
import edu.ucsd.forward.query.logical.term.ElementVariable;
import edu.ucsd.forward.query.logical.term.Parameter;
import edu.ucsd.forward.query.logical.term.QueryPath;
import edu.ucsd.forward.query.logical.term.RelativeVariable;
import edu.ucsd.forward.query.logical.term.Term;
import edu.ucsd.forward.query.logical.visitors.AbstractOperatorVisitor;
import edu.ucsd.forward.util.NameGenerator;
import edu.ucsd.forward.util.NameGeneratorFactory;

/**
 * This modules rewrites a logical plan to introduce a subquery above a given operator. It first inserts the required new operators,
 * then rewrites the operators above them to update the variable references.
 * 
 * @author Romain Vernoux
 * 
 */
public class SubqueryRewriter
{
    @SuppressWarnings("unused")
    private static final Logger                        log = Logger.getLogger(SubqueryRewriter.class);
    
    /**
     * A map that remembers the old and new names of all the attributes kept by the new Project operator, as well as their
     * provenance element variable.
     */
    private Map<RelativeVariable, Map<String, String>> m_element_variables_map;
    
    /**
     * A map that remembers the old and new names of all the other variables in the scope.
     */
    private Map<RelativeVariable, String>              m_variables_map;
    
    /**
     * A set that remembers the name of all the variables that are used above the new Project operator, so that we don't keep
     * unnecessary variables when we introduce the new Project operator.
     */
    private Set<String>                                m_used_variables;
    
    /**
     * The alias of the introduced Subquery operator.
     */
    private ElementVariable                            m_subquery_var;
    
    /**
     * The prefix for the new variables generated by this module.
     */
    private String                                     m_new_var_prefix;
    
    /**
     * The operator being currently translated by a rewriter.
     */
    private Operator                                   m_current_op;
    
    /**
     * Creates a SubqueryRewriter.
     * 
     * @param new_var_prefix
     *            the prefix for the new variables generated by this module.
     */
    public SubqueryRewriter(String new_var_prefix)
    {
        m_element_variables_map = new LinkedHashMap<RelativeVariable, Map<String, String>>();
        m_variables_map = new LinkedHashMap<RelativeVariable, String>();
        m_used_variables = new HashSet<String>();
        m_new_var_prefix = new_var_prefix;
    }
    
    /**
     * Inserts a Subquery operator above the given operator and updates the variable references above it.
     * 
     * @param child
     *            the operator on top of which the Subquery operator will be inserted.
     * @return the subquery operator that has been inserted in the plan
     * @throws QueryCompilationException
     *             if something goes wrong
     */
    public Subquery insertSubquery(Operator child) throws QueryCompilationException
    {
        Project project = new Project();
        String subquery_alias = NameGeneratorFactory.getInstance().getUniqueName(m_new_var_prefix);
        Subquery subquery = new Subquery(subquery_alias);
        m_subquery_var = subquery.getAliasVariable();
        boolean insert_new_project = true;
        
        // Construct the project operator and remembers the relation between old and new variable names.
        for (RelativeVariable rel_var : child.getOutputInfo().getVariables())
        {
            if (rel_var.getName().equals(Project.PROJECT_ALIAS))
            {
                // We want to insert a Subquery somewhere where there is no need to introduce a new Project operator;
                assert (child.getOutputInfo().getVariables().size() == 1);
                // No need to introduce a new Project operator
                insert_new_project = false;
                
                assert (m_element_variables_map.get(rel_var) == null);
                Map<String, String> new_map = new HashMap<String, String>();
                for (String old_alias : ((TupleType) rel_var.getType()).getAttributeNames())
                {
                    // We need to keep the same names so that set operator find isomorphic schemas
                    String new_alias = old_alias;
                    new_map.put(old_alias, new_alias);
                    
                    // All the variables in the element variable should be kept.
                    m_used_variables.add(new_alias);
                }
                m_element_variables_map.put(rel_var, new_map);
                
            }
            else if (rel_var instanceof ElementVariable && rel_var.getType() instanceof TupleType)
            {
                assert (m_element_variables_map.get(rel_var) == null);
                Map<String, String> new_map = new HashMap<String, String>();
                for (String old_alias : ((TupleType) rel_var.getType()).getAttributeNames())
                {
                    String new_alias = NameGeneratorFactory.getInstance().getUniqueName(m_new_var_prefix);
                    project.addProjectionItem(new QueryPath(rel_var, Arrays.asList(old_alias)), new_alias, true);
                    new_map.put(old_alias, new_alias);
                    
                    // All the variables in the element variable should be kept.
                    m_used_variables.add(new_alias);
                }
                m_element_variables_map.put(rel_var, new_map);
            }
            else
            {
                assert (m_variables_map.get(rel_var) == null);
                String new_alias = NameGeneratorFactory.getInstance().getUniqueName(m_new_var_prefix);
                project.addProjectionItem(rel_var, new_alias, true);
                m_variables_map.put(rel_var, new_alias);
            }
        }
        
        // Inserts the operators in the plan
        Operator parent = child.getParent();
        assert (parent != null);
        int index = parent.getChildren().indexOf(child);
        parent.removeChild(child);
        
        Operator subquery_child = child;
        
        if (insert_new_project)
        {
            subquery_child = project;
            project.addChild(child);
        }
        
        subquery.addChild(subquery_child);
        parent.addChild(index, subquery);
        
        if (insert_new_project)
        {
            project.updateOutputInfo();
        }
        subquery.updateOutputInfo();
        
        // Sets the execution data sources
        if (insert_new_project && child.getExecutionDataSourceName() != null)
        {
            project.setExecutionDataSourceName(child.getExecutionDataSourceName());
        }
        if (parent.getExecutionDataSourceName() != null)
        {
            subquery.setExecutionDataSourceName(parent.getExecutionDataSourceName());
        }
        
        // Updates the variable references above child
        VariableReferencesUpdater var_ref_updater = new VariableReferencesUpdater();
        Operator op = subquery;
        do
        {
            m_current_op = op;
            op = op.getParent();
            if (op == null) break;
            op.accept(var_ref_updater);
            for (LogicalPlan used_plan : op.getLogicalPlansUsed())
            {
                ParameterReferencesUpdater param_ref_updater = new ParameterReferencesUpdater(m_element_variables_map,
                                                                                              m_variables_map);
                used_plan.getRootOperator().accept(param_ref_updater);
            }
        } while (!(op instanceof Project || op instanceof GroupBy));
        
        // Remove from the project items all the variables that are not used above.
        List<Project.Item> project_items = new ArrayList<Project.Item>(project.getProjectionItems());
        for (Project.Item item : project_items)
        {
            if (!m_used_variables.contains(item.getAlias()) && insert_new_project && project.getProjectionItems().size() > 1)
            {
                project.removeProjectionItem(item);
            }
        }
        if (insert_new_project && project.getProjectionItems().isEmpty())
        {
            // Add a dummy constant to avoid empty Project item
            project.addProjectionItem(new Constant(new IntegerValue(1)),
                                      NameGeneratorFactory.getInstance().getUniqueName(m_new_var_prefix), true);
        }
        
        return subquery;
    }
    
    /**
     * The rewriter that updates the variable references.
     * 
     * @author Romain Vernoux
     */
    private class VariableReferencesUpdater extends AbstractOperatorVisitor
    {
        /**
         * Updates the variables references in a term.
         * 
         * @param term
         *            the term to rewrite
         * @param op
         *            the operator in which the term is located
         * @return a new term, with updated references.
         */
        private Term updateTerm(Term term, Operator op)
        {
            if (term instanceof QueryPath && m_element_variables_map.containsKey(((QueryPath) term).getTerm()))
            {
                // Update the query path
                QueryPath qp = (QueryPath) term;
                List<String> qp_steps = qp.getPathSteps();
                assert (qp_steps.size() > 0);
                String next_step = qp_steps.get(0);
                String new_alias = m_element_variables_map.get(qp.getTerm()).get(next_step);
                m_used_variables.add(new_alias);
                assert (new_alias != null);
                List<String> new_steps = new ArrayList<String>(qp_steps.size());
                new_steps.add(new_alias);
                for (int i = 1; i < qp_steps.size(); i++)
                    new_steps.add(qp_steps.get(i));
                QueryPath result = new QueryPath(m_subquery_var, new_steps);
                result.setType(term.getType());
                return result;
            }
            else if (term instanceof QueryPath && m_variables_map.containsKey(((QueryPath) term).getTerm()))
            {
                // Update the query path
                QueryPath qp = (QueryPath) term;
                List<String> qp_steps = qp.getPathSteps();
                assert (qp_steps.size() > 0);
                String new_alias = m_variables_map.get(qp.getTerm());
                m_used_variables.add(new_alias);
                assert (new_alias != null);
                List<String> new_steps = new ArrayList<String>(qp_steps.size());
                new_steps.add(new_alias);
                for (int i = 1; i < qp_steps.size(); i++)
                    new_steps.add(qp_steps.get(i));
                QueryPath result = new QueryPath(m_subquery_var, new_steps);
                result.setType(term.getType());
                return result;
            }
            else if (term instanceof ElementVariable && m_element_variables_map.containsKey(term))
            {
                // Reconstruct the ElementVariable with a TupleFunctionCall
                List<Term> args = new ArrayList<Term>();
                for (Entry<String, String> entry : m_element_variables_map.get(term).entrySet())
                {
                    String old_alias = entry.getKey();
                    String new_alias = entry.getValue();
                    m_used_variables.add(new_alias);
                    args.add(new QueryPath(m_subquery_var, Arrays.asList(new_alias)));
                    args.add(new Constant(new StringValue(old_alias)));
                }
                TupleFunctionCall result = new TupleFunctionCall(args);
                result.setType(term.getType());
                return result;
            }
            else if (term instanceof RelativeVariable && m_variables_map.containsKey(term))
            {
                String new_alias = m_variables_map.get(term);
                m_used_variables.add(new_alias);
                QueryPath qp = new QueryPath(m_subquery_var, Arrays.asList(new_alias));
                String fresh_alias = NameGeneratorFactory.getInstance().getUniqueName(NameGenerator.DISTRIBUTOR_VAR_GENERATOR);
                Navigate nav = new Navigate(fresh_alias, qp);
                nav.setExecutionDataSourceName(op.getExecutionDataSourceName());
                LogicalPlanUtil.insertOnTop(m_current_op, nav);
                RelativeVariable result = nav.getAliasVariable();
                result.setType(term.getType());
                return result;
            }
            else if (term instanceof AbstractFunctionCall<?>)
            {
                AbstractFunctionCall<?> func_call = (AbstractFunctionCall<?>) term.copy();
                List<Term> arguments = new ArrayList<Term>(func_call.getArguments());
                for(Term arg: arguments)
                {
                    func_call.removeArgument(arg);
                }
                for (int i = 0; i < arguments.size(); i++)
                {
                    Term arg = arguments.get(i);
                    func_call.addArgument(updateTerm(arg, op));
                }
                func_call.setType(term.getType());
                return func_call;
            }
            else
            {
                // Constant, AbsoluteVariable or Parameter, do nothing
                return term;
            }
        }
        
        @Override
        public Operator visitAntiSemiJoin(AntiSemiJoin operator)
        {
            return visitInnerJoin(operator);
        }
        
        @Override
        public Operator visitAssign(Assign operator)
        {
            // Cannot be below a Project
            throw new AssertionError();
        }
        
        @Override
        public Operator visitApplyPlan(ApplyPlan operator)
        {
            if (operator.hasExecutionCondition())
            {
                operator.setExecutionCondition(updateTerm(operator.getExecutionCondition(), operator));
            }
            return operator;
        }
        
        @Override
        public Operator visitCopy(Copy operator)
        {
            // Should not be in the plan
            throw new AssertionError();
        }
        
        @Override
        public Operator visitEliminateDuplicates(EliminateDuplicates operator)
        {
            return operator;
        }
        
        @Override
        public Operator visitExists(Exists operator)
        {
            if (operator.hasExecutionCondition())
            {
                operator.setExecutionCondition(updateTerm(operator.getExecutionCondition(), operator));
            }
            return operator;
        }
        
        @Override
        public Operator visitGround(Ground operator)
        {
            return operator;
        }
        
        @Override
        public Operator visitGroupBy(GroupBy operator)
        {
            for (Item item : operator.getGroupByItems())
            {
                item.setTerm(updateTerm(item.getTerm(), operator));
            }
            for (Item item : operator.getCarryOnItems())
            {
                item.setTerm(updateTerm(item.getTerm(), operator));
            }
            for (Aggregate agg : operator.getAggregates())
            {
                agg.setAggregateFunctionCall((AggregateFunctionCall) updateTerm(agg.getAggregateFunctionCall(), operator));
            }
            return operator;
        }
        
        @Override
        public Operator visitInnerJoin(InnerJoin operator)
        {
            List<Term> conditions = new ArrayList<Term>(operator.getConditions());
            for (int i = 0; i < conditions.size(); i++)
            {
                Term cond = conditions.get(i);
                operator.removeCondition(cond);
            }
            for (int i = 0; i < conditions.size(); i++)
            {
                Term cond = conditions.get(i);
                operator.addCondition(updateTerm(cond, operator));
            }
            return operator;
        }
        
        @Override
        public Operator visitNavigate(Navigate operator)
        {
            operator.setTerm(updateTerm(operator.getTerm(), operator));
            return operator;
        }
        
        @Override
        public Operator visitOffsetFetch(OffsetFetch operator)
        {
            return operator;
        }
        
        @Override
        public Operator visitOuterJoin(OuterJoin operator)
        {
            List<Term> conditions = new ArrayList<Term>(operator.getConditions());
            for (int i = 0; i < conditions.size(); i++)
            {
                Term cond = conditions.get(i);
                operator.removeCondition(cond);
            }
            for (int i = 0; i < conditions.size(); i++)
            {
                Term cond = conditions.get(i);
                operator.addCondition(updateTerm(cond, operator));
            }
            return operator;
        }
        
        @Override
        public Operator visitPartitionBy(PartitionBy operator)
        {
            List<RelativeVariable> partitionby_terms = new ArrayList<RelativeVariable>(operator.getPartitionByTerms());
            for (int i = 0; i < partitionby_terms.size(); i++)
            {
                RelativeVariable rel_var = partitionby_terms.get(i);
                operator.removePartitionByTerm(rel_var);
            }
            for (int i = 0; i < partitionby_terms.size(); i++)
            {
                RelativeVariable rel_var = partitionby_terms.get(i);
                operator.addPartitionByTerm((RelativeVariable) updateTerm(rel_var, operator));
            }
            for (Sort.Item item : operator.getSortByItems())
            {
                item.setTerm(updateTerm(item.getTerm(), operator));
            }
            return operator;
        }
        
        @Override
        public Operator visitProduct(Product operator)
        {
            return operator;
        }
        
        @Override
        public Operator visitProject(Project operator)
        {
            for (edu.ucsd.forward.query.logical.Project.Item item : operator.getProjectionItems())
            {
                item.setTerm(updateTerm(item.getTerm(), operator));
            }
            return operator;
        }
        
        @Override
        public Operator visitScan(Scan operator)
        {
            operator.setTerm(updateTerm(operator.getTerm(), operator));
            return operator;
        }
        
        @Override
        public Operator visitSelect(Select operator)
        {
            List<Term> conditions = new ArrayList<Term>(operator.getConditions());
            for (int i = 0; i < conditions.size(); i++)
            {
                Term cond = conditions.get(i);
                operator.removeCondition(cond);
            }
            for (int i = 0; i < conditions.size(); i++)
            {
                Term cond = conditions.get(i);
                operator.addCondition(updateTerm(cond, operator));
            }
            return operator;
        }
        
        @Override
        public Operator visitSemiJoin(SemiJoin operator)
        {
            return visitInnerJoin(operator);
        }
        
        @Override
        public Operator visitSendPlan(SendPlan operator)
        {
            // Should not be in the plan
            throw new AssertionError();
        }
        
        @Override
        public Operator visitSetOperator(SetOperator operator)
        {
            return operator;
        }
        
        @Override
        public Operator visitSort(Sort operator)
        {
            for (edu.ucsd.forward.query.logical.Sort.Item item : operator.getSortItems())
            {
                item.setTerm(updateTerm(item.getTerm(), operator));
            }
            return operator;
        }
        
        @Override
        public Operator visitCreateSchemaObject(CreateDataObject operator)
        {
            return operator;
        }
        
        @Override
        public Operator visitDropSchemaObject(DropDataObject operator)
        {
            return operator;
        }
        
        @Override
        public Operator visitInsert(Insert operator)
        {
            return operator;
        }
        
        @Override
        public Operator visitDelete(Delete operator)
        {
            return operator;
        }
        
        @Override
        public Operator visitUpdate(Update operator)
        {
            for (Assignment assign : operator.getAssignments())
            {
                assign.setTerm(updateTerm(assign.getTerm(), operator));
            }
            return operator;
        }
        
        @Override
        public Operator visitIndexScan(IndexScan operator)
        {
            // Should not be in the plan
            throw new AssertionError();
        }
        
        @Override
        public Operator visitSubquery(Subquery operator)
        {
            return operator;
        }
        
    }
    
    /**
     * The rewriter that updates the parameter references.
     * 
     * @author Romain Vernoux
     */
    private class ParameterReferencesUpdater extends AbstractOperatorVisitor
    {
        /**
         * A map that remembers the old and new names of all the attributes kept by the new Project operator, as well as their
         * provenance element variable.
         */
        private Map<RelativeVariable, Map<String, String>> m_element_variables_map;
        
        /**
         * A map that remembers the old and new names of all the other variables in the scope.
         */
        private Map<RelativeVariable, String>              m_variables_map;
        
        /**
         * Creates a ParameterReferencesUpdater that updates the parameter references according to the values contained in the given
         * maps.
         * 
         * @param element_variables_map
         *            the map with the element variables to updates.
         * @param variables_map
         *            the map with the other variables to update.
         */
        public ParameterReferencesUpdater(Map<RelativeVariable, Map<String, String>> element_variables_map,
                Map<RelativeVariable, String> variables_map)
        {
            m_element_variables_map = element_variables_map;
            m_variables_map = variables_map;
        }
        
        /**
         * Returns a copy of the element variables map.
         * 
         * @return a copy of the element variables map
         */
        private Map<RelativeVariable, Map<String, String>> getElementVariablesMapCopy()
        {
            Map<RelativeVariable, Map<String, String>> copy = new HashMap<RelativeVariable, Map<String, String>>();
            for (Entry<RelativeVariable, Map<String, String>> entry : m_element_variables_map.entrySet())
            {
                Map<String, String> subcopy = new HashMap<String, String>(entry.getValue());
                copy.put(entry.getKey(), subcopy);
            }
            return copy;
        }
        
        /**
         * Returns a copy of the variables map.
         * 
         * @return a copy of the variables map
         */
        private Map<RelativeVariable, String> getVariablesMapCopy()
        {
            return new HashMap<RelativeVariable, String>(m_variables_map);
        }
        
        /**
         * Updates the parameter references in a term.
         * 
         * @param term
         *            the term to update
         * @return a new Term, with the updated parameters
         */
        private Term updateParameter(Term term)
        {
            if (term instanceof QueryPath && ((QueryPath) term).getTerm() instanceof Parameter
                    && m_element_variables_map.containsKey(((Parameter) ((QueryPath) term).getTerm()).getTerm()))
            {
                // Update the query path
                QueryPath qp = (QueryPath) term;
                Parameter param = (Parameter) qp.getTerm();
                List<String> qp_steps = qp.getPathSteps();
                assert (qp_steps.size() > 0);
                String next_step = qp_steps.get(0);
                String new_alias = m_element_variables_map.get(param.getVariable()).get(next_step);
                m_used_variables.add(new_alias);
                assert (new_alias != null);
                List<String> new_steps = new ArrayList<String>(qp_steps.size());
                new_steps.add(new_alias);
                for (int i = 1; i < qp_steps.size(); i++)
                    new_steps.add(qp_steps.get(i));
                QueryPath result = new QueryPath(new Parameter(m_subquery_var), new_steps);
                result.setType(term.getType());
                return result;
            }
            else if (term instanceof QueryPath && ((QueryPath) term).getTerm() instanceof Parameter
                    && m_variables_map.containsKey(((Parameter) ((QueryPath) term).getTerm()).getTerm()))
            {
                // Update the query path
                QueryPath qp = (QueryPath) term;
                Parameter param = (Parameter) qp.getTerm();
                List<String> qp_steps = qp.getPathSteps();
                assert (qp_steps.size() > 0);
                String new_alias = m_variables_map.get(param.getTerm());
                m_used_variables.add(new_alias);
                assert (new_alias != null);
                List<String> new_steps = new ArrayList<String>(qp_steps.size());
                new_steps.add(new_alias);
                for (int i = 1; i < qp_steps.size(); i++)
                    new_steps.add(qp_steps.get(i));
                QueryPath result = new QueryPath(new Parameter(m_subquery_var), new_steps);
                result.setType(term.getType());
                return result;
            }
            else if (term instanceof QueryPath)
            {
                // Recursively update the term of the query path
                QueryPath qp = (QueryPath) term;
                Term qp_new_term = updateParameter(qp.getTerm());
                List<String> qp_steps = qp.getPathSteps();
                QueryPath result = new QueryPath(qp_new_term, qp_steps);
                result.setType(term.getType());
                return result;
            }
            else if (term instanceof Parameter && m_element_variables_map.containsKey(((Parameter) term).getTerm()))
            {
                Parameter param = (Parameter) term;
                
                // Reconstruct the ElementVariable with a TupleFunctionCall
                List<Term> args = new ArrayList<Term>();
                for (Entry<String, String> entry : m_element_variables_map.get(param.getTerm()).entrySet())
                {
                    String old_alias = entry.getKey();
                    String new_alias = entry.getValue();
                    m_used_variables.add(new_alias);
                    args.add(new QueryPath(new Parameter(m_subquery_var), Arrays.asList(new_alias)));
                    args.add(new Constant(new StringValue(old_alias)));
                }
                TupleFunctionCall result = new TupleFunctionCall(args);
                result.setType(term.getType());
                return result;
            }
            else if (term instanceof Parameter && m_variables_map.containsKey(((Parameter) term).getTerm()))
            {
                String new_alias = m_variables_map.get(term);
                m_used_variables.add(new_alias);
                QueryPath result = new QueryPath(new Parameter(m_subquery_var), Arrays.asList(new_alias));
                result.setType(term.getType());
                return result;
            }
            else if (term instanceof AbstractFunctionCall<?>)
            {
                AbstractFunctionCall<?> func_call = (AbstractFunctionCall<?>) term.copy();
                List<Term> arguments = new ArrayList<Term>(func_call.getArguments());
                for(Term arg: arguments)
                {
                    func_call.removeArgument(arg);
                }
                for (int i = 0; i < arguments.size(); i++)
                {
                    Term arg = arguments.get(i);
                    func_call.addArgument(i, updateParameter(arg));
                }
                func_call.setType(term.getType());
                return func_call;
            }
            else
            {
                // Constant, AbsoluteVariable or RelativeVariable, do nothing
                return term;
            }
        }
        
        /**
         * Recursively updates the nested plans used by a logical operator.
         * 
         * @param op
         *            the operator to update
         */
        private void updateNestedPlans(Operator op)
        {
            for (LogicalPlan nested_plan : op.getLogicalPlansUsed())
            {
                // Get copies from the current maps
                Map<RelativeVariable, Map<String, String>> elm_var_map_copy = getElementVariablesMapCopy();
                Map<RelativeVariable, String> var_map_copy = getVariablesMapCopy();
                
                // Removes the parameters that are bound by the current operator
                for (Parameter param : op.getBoundParametersUsed())
                {
                    RelativeVariable rel_var = param.getVariable();
                    if (rel_var.getName().equals(Project.PROJECT_ALIAS)
                            || (rel_var instanceof ElementVariable && rel_var.getType() instanceof TupleType))
                    {
                        elm_var_map_copy.remove(rel_var);
                    }
                    else
                    {
                        var_map_copy.remove(rel_var);
                    }
                }
                ParameterReferencesUpdater updater = new ParameterReferencesUpdater(elm_var_map_copy, var_map_copy);
                nested_plan.getRootOperator().accept(updater);
            }
        }
        
        @Override
        public Operator visitAntiSemiJoin(AntiSemiJoin operator)
        {
            return visitInnerJoin(operator);
        }
        
        @Override
        public Operator visitAssign(Assign operator)
        {
            // Cannot be below a Project
            throw new AssertionError();
        }
        
        @Override
        public Operator visitApplyPlan(ApplyPlan operator)
        {
            if (operator.hasExecutionCondition())
            {
                operator.setExecutionCondition(updateParameter(operator.getExecutionCondition()));
            }
            updateNestedPlans(operator);
            
            visitChildren(operator);
            
            return operator;
        }
        
        @Override
        public Operator visitCopy(Copy operator)
        {
            updateNestedPlans(operator);
            
            visitChildren(operator);
            
            return operator;
        }
        
        @Override
        public Operator visitEliminateDuplicates(EliminateDuplicates operator)
        {
            visitChildren(operator);
            
            return operator;
        }
        
        @Override
        public Operator visitExists(Exists operator)
        {
            if (operator.hasExecutionCondition())
            {
                operator.setExecutionCondition(updateParameter(operator.getExecutionCondition()));
            }
            updateNestedPlans(operator);
            
            visitChildren(operator);
            
            return operator;
        }
        
        @Override
        public Operator visitGround(Ground operator)
        {
            return operator;
        }
        
        @Override
        public Operator visitGroupBy(GroupBy operator)
        {
            for (Item item : operator.getGroupByItems())
            {
                item.setTerm(updateParameter(item.getTerm()));
            }
            for (Item item : operator.getCarryOnItems())
            {
                item.setTerm(updateParameter(item.getTerm()));
            }
            for (Aggregate agg : operator.getAggregates())
            {
                agg.setAggregateFunctionCall((AggregateFunctionCall) updateParameter(agg.getAggregateFunctionCall()));
            }
            
            visitChildren(operator);
            
            return operator;
        }
        
        @Override
        public Operator visitInnerJoin(InnerJoin operator)
        {
            List<Term> conditions = new ArrayList<Term>(operator.getConditions());
            for (int i = 0; i < conditions.size(); i++)
            {
                Term cond = conditions.get(i);
                operator.removeCondition(cond);
            }
            for (int i = 0; i < conditions.size(); i++)
            {
                Term cond = conditions.get(i);
                operator.addCondition(updateParameter(cond));
            }
            
            visitChildren(operator);
            
            return operator;
        }
        
        @Override
        public Operator visitNavigate(Navigate operator)
        {
            operator.setTerm(updateParameter(operator.getTerm()));
            
            visitChildren(operator);
            
            return operator;
        }
        
        @Override
        public Operator visitOffsetFetch(OffsetFetch operator)
        {
            visitChildren(operator);
            
            return operator;
        }
        
        @Override
        public Operator visitOuterJoin(OuterJoin operator)
        {
            List<Term> conditions = new ArrayList<Term>(operator.getConditions());
            for (int i = 0; i < conditions.size(); i++)
            {
                Term cond = conditions.get(i);
                operator.removeCondition(cond);
            }
            for (int i = 0; i < conditions.size(); i++)
            {
                Term cond = conditions.get(i);
                operator.addCondition(updateParameter(cond));
            }
            
            visitChildren(operator);
            
            return operator;
        }
        
        @Override
        public Operator visitPartitionBy(PartitionBy operator)
        {
            List<RelativeVariable> partitionby_terms = new ArrayList<RelativeVariable>(operator.getPartitionByTerms());
            for (int i = 0; i < partitionby_terms.size(); i++)
            {
                RelativeVariable rel_var = partitionby_terms.get(i);
                operator.removePartitionByTerm(rel_var);
            }
            for (int i = 0; i < partitionby_terms.size(); i++)
            {
                RelativeVariable rel_var = partitionby_terms.get(i);
                operator.addPartitionByTerm((RelativeVariable) updateParameter(rel_var));
            }
            for (edu.ucsd.forward.query.logical.Sort.Item item : operator.getSortByItems())
            {
                item.setTerm(updateParameter(item.getTerm()));
            }
            
            visitChildren(operator);
            
            return operator;
        }
        
        @Override
        public Operator visitProduct(Product operator)
        {
            visitChildren(operator);
            
            return operator;
        }
        
        @Override
        public Operator visitProject(Project operator)
        {
            for (Project.Item item : operator.getProjectionItems())
            {
                item.setTerm(updateParameter(item.getTerm()));
            }
            
            visitChildren(operator);
            
            return operator;
        }
        
        @Override
        public Operator visitScan(Scan operator)
        {
            operator.setTerm(updateParameter(operator.getTerm()));
            
            visitChildren(operator);
            
            return operator;
        }
        
        @Override
        public Operator visitSelect(Select operator)
        {
            List<Term> conditions = new ArrayList<Term>(operator.getConditions());
            for (int i = 0; i < conditions.size(); i++)
            {
                Term cond = conditions.get(i);
                operator.removeCondition(cond);
            }
            for (int i = 0; i < conditions.size(); i++)
            {
                Term cond = conditions.get(i);
                operator.addCondition(updateParameter(cond));
            }
            
            visitChildren(operator);
            
            return operator;
        }
        
        @Override
        public Operator visitSemiJoin(SemiJoin operator)
        {
            return visitInnerJoin(operator);
        }
        
        @Override
        public Operator visitSendPlan(SendPlan operator)
        {
            // Should not be in the plan
            throw new AssertionError();
        }
        
        @Override
        public Operator visitSetOperator(SetOperator operator)
        {
            visitChildren(operator);
            
            return operator;
        }
        
        @Override
        public Operator visitSort(Sort operator)
        {
            for (edu.ucsd.forward.query.logical.Sort.Item item : operator.getSortItems())
            {
                item.setTerm(updateParameter(item.getTerm()));
            }
            
            visitChildren(operator);
            
            return operator;
        }
        
        @Override
        public Operator visitCreateSchemaObject(CreateDataObject operator)
        {
            updateNestedPlans(operator);
            
            visitChildren(operator);
            
            return operator;
        }
        
        @Override
        public Operator visitDropSchemaObject(DropDataObject operator)
        {
            visitChildren(operator);
            
            return operator;
        }
        
        @Override
        public Operator visitInsert(Insert operator)
        {
            updateNestedPlans(operator);
            
            visitChildren(operator);
            
            return operator;
        }
        
        @Override
        public Operator visitDelete(Delete operator)
        {
            visitChildren(operator);
            
            return operator;
        }
        
        @Override
        public Operator visitUpdate(Update operator)
        {
            updateNestedPlans(operator);
            
            visitChildren(operator);
            
            return operator;
        }
        
        @Override
        public Operator visitIndexScan(IndexScan operator)
        {
            // Should not be in the plan
            throw new AssertionError();
        }
        
        @Override
        public Operator visitSubquery(Subquery operator)
        {
            visitChildren(operator);
            
            return operator;
        }
    }
}
