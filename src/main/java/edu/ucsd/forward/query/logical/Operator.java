package edu.ucsd.forward.query.logical;

import java.io.Serializable;
import java.util.Collection;
import java.util.List;

import edu.ucsd.forward.query.DataSourceCompliance;
import edu.ucsd.forward.query.QueryCompilationException;
import edu.ucsd.forward.query.explain.ExplanationPrinter;
import edu.ucsd.forward.query.logical.term.RelativeVariable;
import edu.ucsd.forward.query.logical.visitors.OperatorVisitor;
import edu.ucsd.forward.util.tree.TreeNode2;

/**
 * Represents a logical operator in a logical query plan, that is, a tree of logical operators. Each logical operator has a unique
 * name, an output type and data object name, and an execution site configuration.
 * 
 * If the logical operator contains a nested logical plan, then the nested logical plan can have parameters that refer to attributes
 * coming from the input operators of the containing logical operator. Note that the nested logical plan is not part of the tree of
 * logical operators that the containing logical operator is part of.
 * 
 * @author Michalis Petropoulos
 */

public interface Operator extends TreeNode2<Operator, Operator, Operator, CardinalityEstimate.Size, Operator>, VariableUsage,
        ParameterUsage, LogicalPlanUsage, CardinalityEstimate, DataSourceCompliance, ExecutionDataSource, ExplanationPrinter, Serializable
{
    /**
     * Returns the unique name of the operator. Right now this name is just the Java class name.
     * 
     * @return the unique name of the operator.
     */
    public String getName();
    
    /**
     * Adds a child operator. The method retains the child operator's cardinality estimation (edge label).
     * 
     * @param child
     *            the child node.
     */
    public void addChild(Operator child);
    
    /**
     * Adds a child operator in the given position. The method retains the child operator's cardinality estimation (edge label).
     * 
     * @param index
     *            the index position.
     * @param child
     *            the child operator.
     */
    public void addChild(int index, Operator child);
    
    /**
     * Removes a child operator.
     * 
     * @param child
     *            the child operator.
     */
    public void removeChild(Operator child);
    
    /**
     * Returns the output info of the operator.
     * 
     * @return the output info.
     */
    public OutputInfo getOutputInfo();
    
    /**
     * Updates the output info of the operator based on the output info of the child operators. This method should also infer the
     * type of all terms used by the operator.
     * 
     * @throws QueryCompilationException
     *             if there is a query compilation error.
     */
    public void updateOutputInfo() throws QueryCompilationException;
    
    /**
     * Returns the input variables to the operator. For unary operators, the input variables are simply the variables in the output
     * info of the child operator. For n-ary operators, the list of input variables is the concatenation of the variables in the
     * output info of the child operators. The lists of input variables are concatenated in the order of the child operators.
     * 
     * @return the input variables.
     */
    public List<RelativeVariable> getInputVariables();
    
    /**
     * Asking an operator to accept a visitor.
     * 
     * @param visitor
     *            the visitor to accept.
     * @return an operator.
     */
    public Operator accept(OperatorVisitor visitor);
    
    /**
     * Get all descendants and self of type InnerJoin.
     * 
     * @return all the descendants and self of type InnerJoin.
     */
    public Collection<InnerJoin> getInnerJoinDescendantsAndSelf();
    
    /**
     * Creates a copy of the operator without copying its children. The caller of this method is responsible for calling the
     * Operator.updateOutputInfo method, since the information generated by that method, such as the output info, is not copied.
     * 
     * @return a copied operator.
     */
    public Operator copy();
    
    /**
     * Copies the operator without type information. The type information may be missing in the current object.
     * 
     * Kevin: I create this method because it is more independent than copy().
     * 
     * @return a copy.
     */
    public Operator copyWithoutType();
    
}
