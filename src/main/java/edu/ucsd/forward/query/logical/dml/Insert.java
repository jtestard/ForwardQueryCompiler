/**
 * 
 */
package edu.ucsd.forward.query.logical.dml;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import edu.ucsd.app2you.util.logger.Logger;
import edu.ucsd.forward.data.TypeUtil;
import edu.ucsd.forward.data.source.DataSourceMetaData;
import edu.ucsd.forward.data.type.CollectionType;
import edu.ucsd.forward.data.type.ScalarType;
import edu.ucsd.forward.data.type.TupleType;
import edu.ucsd.forward.data.type.Type;
import edu.ucsd.forward.data.type.TypeConverter;
import edu.ucsd.forward.exception.ExceptionMessages.QueryCompilation;
import edu.ucsd.forward.query.QueryCompilationException;
import edu.ucsd.forward.query.QueryProcessor;
import edu.ucsd.forward.query.QueryProcessorFactory;
import edu.ucsd.forward.query.logical.NestedPlansOperator;
import edu.ucsd.forward.query.logical.Operator;
import edu.ucsd.forward.query.logical.Scan;
import edu.ucsd.forward.query.logical.plan.LogicalPlan;
import edu.ucsd.forward.query.logical.term.Parameter;
import edu.ucsd.forward.query.logical.term.Term;
import edu.ucsd.forward.query.logical.term.Variable;
import edu.ucsd.forward.query.logical.visitors.OperatorVisitor;

/**
 * Represents an operator that insert tuple(s) into a collection. The tuple(s) are generated by a nested logical plan.
 * 
 * @author Yupeng
 * @author Michalis Petropoulos
 * 
 */
@SuppressWarnings("serial")
public class Insert extends AbstractDmlOperator implements NestedPlansOperator
{
    @SuppressWarnings("unused")
    private static final Logger log = Logger.getLogger(Insert.class);
    
    /**
     * The target attributes to insert.
     */
    private List<String>        m_target_attrs;
    
    /**
     * The logical plan to insert.
     */
    private LogicalPlan         m_insert_plan;
    
    /**
     * The bound parameters.
     */
    private List<Parameter>     m_bound_params;
    
    /**
     * Initializes an instance of the operator.
     * 
     * @param target_data_source
     *            the target data source.
     * @param target_term
     *            the target term to modify.
     */
    public Insert(String target_data_source, Term target_term)
    {
        super(target_data_source, target_term);
    }
    
    /**
     * Default constructor.
     */
    @SuppressWarnings("unused")
    private Insert()
    {
        
    }
    
    /**
     * Sets the plan to insert.
     * 
     * @param insert_plan
     *            the plan to insert.
     */
    public void setInsertPlan(LogicalPlan insert_plan)
    {
        assert insert_plan != null;
        m_insert_plan = insert_plan;
    }
    
    /**
     * Gets the target attributes.
     * 
     * @return the target attributes.
     */
    public List<String> getTargetAttributes()
    {
        return m_target_attrs;
    }
    
    /**
     * Sets the the target attributes.
     * 
     * @param target_attrs
     *            the list of target attributes.
     */
    public void setTargetAttributes(List<String> target_attrs)
    {
        assert (target_attrs != null);
        assert (!target_attrs.isEmpty());
        
        m_target_attrs = target_attrs;
    }
    
    /**
     * Gets the logical insert plan.
     * 
     * @return the logical insert plan.
     */
    public LogicalPlan getLogicalPlan()
    {
        return m_insert_plan;
    }
    
    @Override
    public List<Variable> getVariablesUsed()
    {
        return this.getTargetTerm().getVariablesUsed();
    }
    
    @Override
    public List<LogicalPlan> getLogicalPlansUsed()
    {
        return Collections.<LogicalPlan> singletonList(m_insert_plan);
    }
    
    @Override
    public List<Parameter> getBoundParametersUsed()
    {
        // Needed during parsing of an existing plan
        if (m_bound_params == null)
        {
            this.setBoundParametersUsed();
        }
        
        return m_bound_params;
    }
    
    /**
     * Sets the bounding parameters used by the operator.
     */
    private void setBoundParametersUsed()
    {
        m_bound_params = new ArrayList<Parameter>(m_insert_plan.getFreeParametersUsed());
        m_bound_params.removeAll(this.getFreeParametersUsed());
    }
    
    
    @Override
    public Scan getTargetScan()
    {
        throw new UnsupportedOperationException();
    }

    
    @Override
    public void updateOutputInfo() throws QueryCompilationException
    {
        if (m_insert_plan == null) return;
        
        // Set the bound parameters
        this.setBoundParametersUsed();
        
        // Validate the bound parameters
        for (Parameter param : this.getBoundParametersUsed())
            param.getTerm().inferType(this.getChildren());
        
        // Set the target collection type
        Type target_type = this.getTargetTerm().inferType(this.getChildren());
        
        // Unexpected target type
        if (!(target_type instanceof CollectionType))
        {
            throw new QueryCompilationException(QueryCompilation.DML_NON_COLLECTION_TARGET_TYPE,
                                                this.getTargetTerm().getLocation(), this.getTargetTerm().toString());
        }
        
        this.setTargetTupleType(((CollectionType) target_type).getTupleType());
        
        // Check validity of target attributes
        for (String attr_name : m_target_attrs)
            // Invalid target attribute
            if (!this.getTargetTupleType().hasAttribute(attr_name))
            {
                throw new QueryCompilationException(QueryCompilation.DML_INVALID_TARGET_ATTR, this.getTargetTerm().getLocation(),
                                                    attr_name, this.getTargetTerm().toString());
            }
        
        // Check type compatibility
        QueryProcessor processor = QueryProcessorFactory.getInstance();
        Type provided = processor.getOutputType(m_insert_plan, processor.getUnifiedApplicationState());
        // FIXME Throw an Unexpected provided type exception
        assert (provided instanceof CollectionType || provided instanceof TupleType);
        TupleType provided_tuple_type = null;
        if (provided instanceof CollectionType)
        {
            provided_tuple_type = ((CollectionType) provided).getTupleType();
        }
        else
        {
            provided_tuple_type = (TupleType) provided;
        }
        
        // Unequal number of provided and target attributes
        if (m_target_attrs.size() != provided_tuple_type.getSize())
        {
            throw new QueryCompilationException(QueryCompilation.DML_UNEQUAL_PROVIDED_TARGET_ATTRS,
                                                this.getTargetTerm().getLocation(), this.getTargetTerm().toString());
        }
        
        Iterator<String> target_iter = m_target_attrs.iterator();
        Iterator<String> provided_iter = provided_tuple_type.getAttributeNames().iterator();
        while (target_iter.hasNext())
        {
            String target_attr_name = target_iter.next();
            
            Type provided_attr_type = provided_tuple_type.getAttribute(provided_iter.next());
            Type target_attr_type = this.getTargetTupleType().getAttribute(target_attr_name);
            
            boolean safe = true;
            if (provided_attr_type instanceof ScalarType && target_attr_type instanceof ScalarType)
            {
                safe = TypeConverter.getInstance().canImplicitlyConvert(provided_attr_type, target_attr_type);
            }
            else
            {
                safe = TypeUtil.deepEqualsByIsomorphism(provided_attr_type, target_attr_type, false);
            }
            
            // Incompatible types
            if (!safe)
            {
                throw new QueryCompilationException(QueryCompilation.DML_INVALID_PROVIDED_TYPE,
                                                    this.getTargetTerm().getLocation(), target_attr_name);
            }
        }
        
        super.updateOutputInfo();
    }
    
    @Override
    public boolean isDataSourceCompliant(DataSourceMetaData metadata)
    {
        boolean compliant = super.isDataSourceCompliant(metadata);
        switch (metadata.getDataModel())
        {
            case SQLPLUSPLUS:
                return compliant;
            case RELATIONAL:
                // Only modification on flat collection is SQL-compliant
                return compliant && m_insert_plan.isDataSourceCompliant(metadata);
            default:
                throw new AssertionError();
        }
    }
    
    @Override
    public String toExplainString()
    {
        return super.toExplainString() + " - " + this.getTargetTerm().toExplainString();
    }
    
    @Override
    public Operator accept(OperatorVisitor visitor)
    {
        return visitor.visitInsert(this);
    }
    
    @Override
    public Operator copy()
    {
        Insert copy = new Insert(this.getTargetDataSourceName(), this.getTargetTerm().copy());
        super.copy(copy);
        
        copy.setInsertPlan(m_insert_plan.copy());
        copy.setTargetAttributes(m_target_attrs);
        
        return copy;
    }    
}
