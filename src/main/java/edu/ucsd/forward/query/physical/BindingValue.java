/**
 * 
 */
package edu.ucsd.forward.query.physical;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

import edu.ucsd.app2you.util.identity.HashCodeUtil;
import edu.ucsd.app2you.util.logger.Logger;
import edu.ucsd.forward.data.ValueUtil;
import edu.ucsd.forward.data.java.JavaToSqlMapUtil;
import edu.ucsd.forward.data.json.JsonToValueConverter;
import edu.ucsd.forward.data.type.Type;
import edu.ucsd.forward.data.type.TypeConverter;
import edu.ucsd.forward.data.type.TypeException;
import edu.ucsd.forward.data.value.JsonValue;
import edu.ucsd.forward.data.value.NullValue;
import edu.ucsd.forward.data.value.PrimitiveValue;
import edu.ucsd.forward.data.value.ScalarValue;
import edu.ucsd.forward.data.value.TupleValue;
import edu.ucsd.forward.data.value.Value;
import edu.ucsd.forward.exception.ExceptionMessages.QueryExecution;
import edu.ucsd.forward.query.QueryExecutionException;

/**
 * Represents a value generated by a physical operator. A binding item provides information of whether the corresponding value is
 * cloned or appears in an existing data tree and was retrieved by a leaf operator.
 * 
 * @author Michalis Petropoulos
 * 
 */
@SuppressWarnings("serial")
public class BindingValue implements Comparable<BindingValue>, Serializable
{
    @SuppressWarnings("unused")
    private static final Logger log = Logger.getLogger(BindingValue.class);
    
    private Value               m_value;
    
    private boolean             m_is_cloned;
    
    public BindingValue()
    {
        
    }
    
    /**
     * Default constructor.
     * 
     * @param value
     *            the value of the binding value.
     * @param is_cloned
     *            the flag determining whether the value is cloned or not.
     */
    public BindingValue(Value value, boolean is_cloned)
    {
        assert (value != null);
        
        m_value = value;
        m_is_cloned = is_cloned;
    }
    
    /**
     * Returns the value.
     * 
     * @return a value.
     */
    public Value getValue()
    {
        return m_value;
    }
    
    /**
     * Returns the value in SQL value. This will cast Java value into SQL in a best-effort way.
     * 
     * @return the value converted to SQL value.
     * @throws QueryExecutionException
     *             if the Java value cannot be casted to SQL value
     */
    public Value getSqlValue() throws QueryExecutionException
    {
        if (m_value instanceof JsonValue)
        {
            JsonValue json_value = (JsonValue) m_value;
            try
            {
                return JsonToValueConverter.mapScalar(json_value);
            }
            catch (TypeException e)
            {
                throw new QueryExecutionException(QueryExecution.JSON_CAST_ERROR, e);
            }
        }
        return m_value;
    }
    
    /**
     * Returns the value in SQL value that is casted to the specific type.
     * 
     * @param target_type
     *            the specific type to cast to
     * @return the value converted to SQL value.
     * @throws QueryExecutionException
     *             if the Java value cannot be casted to SQL value.
     */
    public Value getSqlValue(Type target_type) throws QueryExecutionException
    {
        if (m_value instanceof JsonValue)
        {
            JsonValue json_value = (JsonValue) m_value;
            return JsonToValueConverter.convert(json_value, target_type);
        }
        else
        {
            // Handle NULL arguments
            if (m_value instanceof NullValue)
            {
                return m_value;
            }
            
            // Cast only if needed
            if (m_value.getTypeClass() != target_type.getClass())
            {
                Value value;
                try
                {
                    value = TypeConverter.getInstance().convert(m_value, target_type);
                }
                catch (TypeException e)
                {
                    // Chain the exception
                    throw new QueryExecutionException(QueryExecution.CAST_ERROR, e);
                }
                
                return value;
            }
        }
        return m_value;
    }
    
    /**
     * Determines whether the value is cloned or not.
     * 
     * @return true if the value is cloned; false, otherwise.
     */
    public boolean isCloned()
    {
        return m_is_cloned;
    }
    
    /**
     * Resets the cloned flag to false.
     */
    public void resetCloned()
    {
        m_is_cloned = false;
    }
    
    @Override
    public boolean equals(Object other)
    {
        assert (other instanceof BindingValue);
        
        Value left = m_value;
        if (left instanceof JsonValue) try
        {
            left = getSqlValue();
        }
        catch (QueryExecutionException e1)
        {
            throw new UnsupportedOperationException();
        }
        Value right = ((BindingValue) other).getValue();
        if (right instanceof JsonValue) try
        {
            right = ((BindingValue) other).getSqlValue();
        }
        catch (QueryExecutionException e1)
        {
            throw new UnsupportedOperationException();
        }
        
        // One type can be the NullType
        if (left.getTypeClass() != right.getTypeClass()) return false;
        
        // THIS METHOD CONSIDERES TWO NULL VALUES TO BE EQUAL. THIS IS USEFUL FOR HASHING NULL VALUES IN THE SAME BUCKET IN BINDING
        // BUFFERS. HANDLING OF NULL VALUES IS LEFT TO THE CALLER OF THIS METHOD.
        
        // This method is consistent with the compareTo method ONLY in the case of PrimitiveValues and NullValues.
        
        if (m_value instanceof PrimitiveValue<?>)
        {
            return (this.compareTo((BindingValue) other) == 0) ? true : false;
        }
        else if (m_value instanceof NullValue)
        {
            return (this.compareTo((BindingValue) other) == 0) ? true : false;
        }
        else if (m_value instanceof ScalarValue)
        {
            return ValueUtil.deepEquals(this.getValue(), ((BindingValue) other).getValue());
        }
        else if (m_value instanceof TupleValue)
        {
            // FIXME: Consider first level only or all nested levels.
            return ValueUtil.deepEquals(this.getValue(), ((BindingValue) other).getValue());
        }
        else
        {
            // Complex values are compared not supported
            throw new UnsupportedOperationException();
        }
    }
    
    @Override
    public int hashCode()
    {
        // This method does not violate the general contract of hashCode.
        
        if (m_value instanceof ScalarValue)
        {
            return HashCodeUtil.hashCode(((ScalarValue) m_value).getObject());
        }
        else if (m_value instanceof NullValue)
        {
            return HashCodeUtil.hashCode((Object) null);
        }
        else if (m_value instanceof JsonValue)
        {
            return HashCodeUtil.hashCode(((JsonValue) m_value).getElement());
        }
        else if (m_value instanceof TupleValue)
        {
            // We do one-level navigation into the attributes.
            List<Object> hash_list = new ArrayList<Object>();
            TupleValue tuple = (TupleValue) m_value;
            for (String name : tuple.getAttributeNames())
            {
                Value value = tuple.getAttribute(name);
                if (value instanceof ScalarValue)
                {
                    hash_list.add(((ScalarValue) value).getObject());
                }
                else if (value instanceof NullValue)
                {
                    hash_list.add((Object) null);
                }
                else
                {
                    // Complex values are not supported
                    throw new UnsupportedOperationException();
                }
            }
            return HashCodeUtil.hashCode(hash_list);
        }
        else
        {
            // Complex values are not supported
            throw new UnsupportedOperationException();
        }
        
    }
    
    @Override
    @SuppressWarnings("unchecked")
    public int compareTo(BindingValue other)
    {
        // THIS METHOD CONSIDERES TWO NULL VALUES TO BE EQUAL. THIS IS USEFUL FOR HASHING NULL VALUES IN THE SAME BUCKET IN BINDING
        // BUFFERS. HANDLING OF NULL VALUES IS LEFT TO THE CALLER OF THIS METHOD.
        
        // This method is consistent with the equals method ONLY in the case of PrimitiveValues and NullValues.
        
        Value left = m_value;
        if (left instanceof JsonValue) try
        {
            left = getSqlValue();
        }
        catch (QueryExecutionException e1)
        {
            throw new UnsupportedOperationException();
        }
        Value right = ((BindingValue) other).getValue();
        if (right instanceof JsonValue) try
        {
            right = ((BindingValue) other).getSqlValue();
        }
        catch (QueryExecutionException e1)
        {
            throw new UnsupportedOperationException();
        }
        
        // NULL values
        if (left instanceof NullValue && right instanceof NullValue) return 0;
        // Left NULL value only
        else if (left instanceof NullValue) return -1;
        // Right NULL value only
        else if (right instanceof NullValue) return 1;
        
        // Unable to compare complex values
        if (!(left instanceof PrimitiveValue<?>) || !(right instanceof PrimitiveValue<?>))
        {
            // Complex and scalar values are not supported
            throw new UnsupportedOperationException();
        }
        
        assert (left.getTypeClass() == right.getTypeClass());
        
        return ((PrimitiveValue) left).getObject().compareTo(((PrimitiveValue) right).getObject());
    }
}
