/**
 * 
 */
package edu.ucsd.forward.query.physical;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import edu.ucsd.app2you.util.identity.HashCodeUtil;
import edu.ucsd.app2you.util.logger.Logger;
import edu.ucsd.forward.data.ValueUtil;
import edu.ucsd.forward.data.value.TupleValue;
import edu.ucsd.forward.data.value.Value;
import edu.ucsd.forward.query.explain.ExplanationPrinter;
import edu.ucsd.forward.query.logical.OutputInfo;
import edu.ucsd.forward.query.logical.term.RelativeVariable;
import edu.ucsd.forward.util.NameGenerator;

/**
 * Represents a list of binding values that captures an intermediate result generated by a physical operator. The list of binding
 * values correspond to the output schema of the operator, and is a lightweight version of the tuple value. The values of the
 * binding can only be accessed by index position, which can be obtained by the output info of the operator.
 * 
 * @author Michalis Petropoulos
 * 
 */
public class Binding implements Comparable<Binding>, ExplanationPrinter, Serializable
{
    @SuppressWarnings("unused")
    private static final Logger log = Logger.getLogger(Binding.class);
    
    private List<BindingValue>  m_values;
    
    /**
     * Default constructor.
     */
    public Binding()
    {
        m_values = new ArrayList<BindingValue>();
    }
    
    /**
     * Returns the number of values, that is, the size of the binding.
     * 
     * @return the number of values.
     */
    public int size()
    {
        return m_values.size();
    }
    
    /**
     * Returns the values.
     * 
     * @return a list of values.
     */
    public List<BindingValue> getValues()
    {
        return m_values;
    }
    
    /**
     * Returns the value corresponding to the input index position.
     * 
     * @param index
     *            the index position.
     * @return a value.
     */
    public BindingValue getValue(int index)
    {
        return m_values.get(index);
    }
    
    /**
     * Adds an input value to the binding.
     * 
     * @param value
     *            the value to add.
     */
    public void addValue(BindingValue value)
    {
        m_values.add(value);
    }
    
    /**
     * Appends a list of values to the binding.
     * 
     * @param values
     *            the list of values to add.
     */
    public void addValues(List<BindingValue> values)
    {
        m_values.addAll(values);
    }
    
    /**
     * Resets the cloned flag of all binding values to false.
     */
    public void resetCloned()
    {
        for (BindingValue value : m_values)
            value.resetCloned();
    }
    
    @Override
    public boolean equals(Object other)
    {
        Iterator<BindingValue> left = m_values.iterator();
        Iterator<BindingValue> right = ((Binding) other).getValues().iterator();
        
        BindingValue left_value;
        BindingValue right_value;
        
        // Iterate over the binding values of the two bindings
        while (left.hasNext() && right.hasNext())
        {
            left_value = left.next();
            right_value = right.next();
            
            if (!left_value.equals(right_value)) return false;
        }
        
        if (left.hasNext() || right.hasNext())
        {
            return false;
        }
        
        return true;
    }
    
    @Override
    public int hashCode()
    {
        // This method does not violate the general contract of hashCode.
        
        List<Object> hash_list = new ArrayList<Object>();
        
        for (BindingValue b_value : m_values)
        {
            hash_list.add(b_value.hashCode());
        }
        
        return HashCodeUtil.hashCode(hash_list);
    }
    
    @Override
    public int compareTo(Binding other)
    {
        int result;
        Iterator<BindingValue> left = m_values.iterator();
        Iterator<BindingValue> right = ((Binding) other).getValues().iterator();
        BindingValue left_value;
        BindingValue right_value;
        
        // Iterate over the binding values of the two bindings
        while (left.hasNext() && right.hasNext())
        {
            left_value = left.next();
            right_value = right.next();
            
            result = left_value.compareTo(right_value);
            
            if (result != 0) return result;
        }
        
        if (left.hasNext() || right.hasNext())
        {
            // Unable to compare heterogeneous bindings
            throw new UnsupportedOperationException();
        }
        
        return 0;
    }
    
    @Override
    public String toExplainString()
    {
        String str = "{ ";
        for (BindingValue value : m_values)
        {
            str += value.getValue().toString() + " (" + value.isCloned() + ")" + ", ";
        }
        if (!m_values.isEmpty()) str = str.substring(0, str.length() - 2);
        
        return str + " }";
    }
    
    @Override
    public String toString()
    {
        return this.toExplainString();
    }
    
    /**
     * Utility function that converts a binding into a tuple value given an output info. Clones of values that have not been cloned
     * yet are created.
     * 
     * @param output_info
     *            the output_info of the operator that produced the binding.
     * @return a tuple value.
     */
    @Deprecated
    public TupleValue toTupleValue(OutputInfo output_info)
    {
        // Wrap the binding in a tuple value
        TupleValue tuple_value = new TupleValue();
        int index = 0;
        for (RelativeVariable var : output_info.getVariables())
        {
            Value attribute_value = this.getValue(index).getValue();
            if (!this.getValue(index).isCloned())
            {
                // Make a copy of the value, because the original value already has a tuple parent.
                attribute_value = ValueUtil.cloneNoParentNoType(attribute_value);
            }
            tuple_value.setAttribute(var.getDefaultProjectAlias(), attribute_value);
            index++;
        }
        
        return tuple_value;
    }
    
    /**
     * Utility function that converts a binding into a value given an output info. Clones of values that have not been cloned yet
     * are created.
     * 
     * @return the value.
     */
    public Value toValue()
    {
        // Normal form assumption: the binding contains a single binding value that is the value we want.
        assert (m_values.size() == 1);
        
        Value value = m_values.get(0).getValue();
        if(!m_values.get(0).isCloned())
        {
            value = ValueUtil.cloneNoParentNoType(value);
        }
        
        return value;
    }
    
}
