/**
 * JavaCC for SQL++ query language
 */options{  STATIC = true;  JAVA_UNICODE_ESCAPE = true;  UNICODE_INPUT = true;  IGNORE_CASE = true;  JDK_VERSION = "1.6";  DEBUG_PARSER = false;  DEBUG_LOOKAHEAD = false;  DEBUG_TOKEN_MANAGER = false;}PARSER_BEGIN(QueryParser)package edu.ucsd.forward.query.parser;import edu.ucsd.app2you.util.collection.Pair;import edu.ucsd.forward.fpl.FplParsingException;import edu.ucsd.forward.fpl.ast.*;import edu.ucsd.forward.query.QueryParsingException;import edu.ucsd.forward.query.ast.*;import edu.ucsd.forward.query.ast.ddl.*;import edu.ucsd.forward.query.ast.dml.*;import edu.ucsd.forward.query.ast.function.*;import edu.ucsd.forward.query.ast.literal.*;import edu.ucsd.forward.query.function.*;import edu.ucsd.forward.query.function.aggregate.*;import edu.ucsd.forward.query.function.cast.*;import edu.ucsd.forward.query.function.comparison.*;import edu.ucsd.forward.query.function.conditional.*;import edu.ucsd.forward.query.function.general.*;import edu.ucsd.forward.query.function.logical.*;import edu.ucsd.forward.query.function.math.*;import edu.ucsd.forward.query.function.pattern_matching.*;import edu.ucsd.forward.query.function.string.*;import edu.ucsd.forward.query.function.tuple.*;import edu.ucsd.forward.data.SchemaPath;import edu.ucsd.forward.data.TypeUtil;import edu.ucsd.forward.data.constraint.*;import edu.ucsd.forward.data.type.*;import edu.ucsd.forward.data.value.ScalarValue;import edu.ucsd.forward.exception.*;import edu.ucsd.forward.util.tree.TreePath.PathMode;import edu.ucsd.forward.exception.ExceptionMessages.QueryParsing;import java.io.ByteArrayInputStream;import java.io.InputStream;import java.io.UnsupportedEncodingException;import java.io.StringReader;import java.util.Collections;import java.util.List;import java.util.ArrayList;public class QueryParser{  private static int m_offset_line = 0;  private static int m_offset_column = 0;  private static String m_path = null;  public synchronized List < AstTree > parseQuery(String input, String path, int offset_line, int offset_column) throws QueryParsingException  {    m_offset_line = offset_line;    m_offset_column = offset_column;    m_path = path;    try    {      StringReader sr = new StringReader(input);      ReInit(sr);      return query_start();    }    catch (ParseException ex)    {      throw QueryParsingException.create(ex, m_path);    }    catch (TokenMgrError ex)    {      throw QueryParsingException.create(ex, m_path);    }  }  public synchronized List < Definition > parseFplCode(String input, String path, int offset_line, int offset_column) throws FplParsingException  {    m_offset_line = offset_line;    m_offset_column = offset_column;    m_path = path;    try    {      StringReader sr = new StringReader(input);      ReInit(sr);      return action_start();    }    catch (ParseException ex)    {      throw QueryParsingException.create(ex, m_path);    }    catch (TokenMgrError ex)    {      throw QueryParsingException.create(ex, m_path);    }  }  public synchronized ActionInvocation parseActionInvocation(String input, String path, int offset_line, int offset_column) throws FplParsingException  {    m_offset_line = offset_line;    m_offset_column = offset_column;    m_path = path;    try    {      StringReader sr = new StringReader(input);      ReInit(sr);      return action_invocation();    }    catch (ParseException ex)    {      throw QueryParsingException.create(ex, m_path);    }    catch (TokenMgrError ex)    {      throw QueryParsingException.create(ex, m_path);    }  }  public static synchronized void setStaticLocationInfo(String path, int offset_line, int offset_column)  {    m_offset_line = offset_line;    m_offset_column = offset_column;    m_path = path;  }  public static void main(String args []) throws ParseException  {    QueryParser parser = new QueryParser(new StringReader(""));    List < AstTree > tree_list;    while (true)    {      System.out.print("Enter a query:");      try      {        tree_list = parser.query_start();        for (AstTree ast_tree : tree_list) System.out.println(ast_tree);      }      catch (Exception e)      {        System.out.println("NOK.");        System.out.println(e.getMessage());        parser.ReInit(new StringReader(""));      }      catch (Error e)      {        System.out.println("Oops.");        System.out.println(e.getMessage());        break;      }    }  }}PARSER_END(QueryParser)/////////////////////////////////////////////////////////////////////
// 0 START
/////////////////////////////////////////////////////////////////////
List < AstTree > query_start() throws QueryParsingException :{  List < AstTree > tree_list = new ArrayList < AstTree > ();  QueryStatement statement;}{  statement = direct_SQL_statement()  {    tree_list.add(new AstTree(statement));  }  (    < C_SEMICOLON >    [      statement = direct_SQL_statement()      {        tree_list.add(new AstTree(statement));      }    ]  )*  < EOF >  {    return tree_list;  }}List < Definition > action_start() throws FplParsingException :{  List < Definition > all_def_list = new ArrayList < Definition > ();  List < Definition > def_list;  FunctionDefinition function;}{  (    LOOKAHEAD(2)    def_list = create_action()    {      all_def_list.addAll(def_list);    }  | function = create_function()    {      all_def_list.add(function);    }  )+  < EOF >  {    return all_def_list;  }}/////////////////////////////////////////////////////////////////////
// 5 LEXICAL ELEMENTS
/////////////////////////////////////////////////////////////////////
SKIP :{  " "| "\t"| "\r"| "\n"| "\f"| < "--" (~[ "\n" ])* > // Single line comment
| < "//" (~[ "\n" ])* > // Single line comment
| "/*" : IN_COMMENT // When a /* is seen in the DEFAULT state, skip it and switch to the IN_COMMENT state
}// When any other character is seen in the IN_COMMENT state, skip it.
< IN_COMMENT >SKIP :{  < ~[ ] >}// When a */ is seen in the IN_COMMENT state, skip it and switch back to the DEFAULT state
< IN_COMMENT >SKIP :{  "*/" : DEFAULT}TOKEN : /* SQL terminal characters (prefixed with C_) */{  < #C_SIMPLE_LATIN_LETTER : [ "a"-"z", "A"-"Z" ] >| < #C_DIGIT : [ "0"-"9" ] >| < C_QUOTE : "'" > : IN_LITERAL| < C_LEFT_PAREN : "(" >| < C_RIGHT_PAREN : ")" >| < C_LEFT_BRACE : "{" >| < C_RIGHT_BRACE : "}" >| < C_LEFT_BRACKET : "[" >| < C_RIGHT_BRACKET : "]" >| < C_ASTERISK : "*" >| < C_PLUS_SIGN : "+" >| < C_COMMA : "," >| < C_MINUS_SIGN : "-" >| < C_PERIOD : "." >| < C_SOLIDUS : "/" >| < C_COLON : ":" >| < C_SEMICOLON : ";" >| < C_LESS_THAN_OPERATOR : "<" >| < C_EQUALS_OPERATOR : "=" >| < C_GREATER_THAN_OPERATOR : ">" >| < #C_UNDERSCORE : "_" >| < #C_VERTICAL_BAR : "|" >}TOKEN : /* delimiter tokens (prefixed with DT_) */{  < DT_NOT_EQUALS_OPERATOR : < C_LESS_THAN_OPERATOR > < C_GREATER_THAN_OPERATOR >>| < DT_GREATER_THAN__OR_EQUALS_OPERATOR : < C_GREATER_THAN_OPERATOR > < C_EQUALS_OPERATOR >>| < DT_LESS_THAN_OR_EQUALS_OPERATOR : < C_LESS_THAN_OPERATOR > < C_EQUALS_OPERATOR >>| < DT_CONCATENATION_OPERATOR : < C_VERTICAL_BAR > < C_VERTICAL_BAR >>}TOKEN : /* reserved keywords (prefixed with K_) */{  < K_ACCESS : "ACCESS" >| < K_ALL : "ALL" >| < K_AND : "AND" >| < K_AS : "AS" >| < K_AT : "AT" >| < K_AVG : "AVG" >| < K_BAG : "BAG" >| < K_BOOLEAN : "BOOLEAN" >| < K_BY : "BY" >| < K_CALL : "CALL" >| < K_CASE : "CASE" >| < K_CAST : "CAST" >| < K_CREATE : "CREATE" >| < K_CROSS : "CROSS" >| < K_COLLECTION : "COLLECTION" >| < K_COUNT : "COUNT" >| < K_DATA : "DATA" >| < K_DATE : "DATE" >| < K_DECIMAL : "DECIMAL" >| < K_DEFAULT : "DEFAULT" >| < K_DELETE : "DELETE" >| < K_DISTINCT : "DISTINCT" >| < K_DOUBLE : "DOUBLE" >| < K_DROP : "DROP" >| < K_ELEMENT : "ELEMENT" >| < K_ELSE : "ELSE" >| < K_END : "END" >| < K_EXCEPT : "EXCEPT" >| < K_EXISTS : "EXISTS" >| < K_FALSE : "FALSE" >| < K_FETCH : "FETCH" >| < K_FLATTEN : "FLATTEN" >| < K_FLOAT : "FLOAT" >| < K_FOR : "FOR" >| < K_FROM : "FROM" >| < K_FULL : "FULL" >| < K_GET : "GET" >| < K_GROUP : "GROUP" >| < K_HAVING : "HAVING" >| < K_IN : "IN" >| < K_INLINE : "INLINE" >| < K_INNER : "INNER" >| < K_INSERT : "INSERT" >| < K_INTEGER : "INTEGER" >| < K_INTERSECT : "INTERSECT" >| < K_INTO : "INTO" >| < K_IS : "IS" >| < K_JOIN : "JOIN" >| < K_KEY : "KEY" >| < K_LEFT : "LEFT" >| < K_LIKE : "LIKE" >| < K_LIMIT : "LIMIT" >| < K_LIST : "LIST" >| < K_LONG : "LONG" >| < K_MAX : "MAX" >| < K_MIN : "MIN" >| < K_NATURAL : "NATURAL" >| < K_NEST : "NEST" >| < K_NEW : "NEW" >| < K_NOT : "NOT" >| < K_NULL : "NULL" >| < K_OBJECT : "OBJECT" >| < K_OFFSET : "OFFSET" >| < K_ON : "ON" >| < K_ONLY : "ONLY" >| < K_OR : "OR" >| < K_ORDER : "ORDER" >| < K_OUTER : "OUTER" >| < K_PRIMARY : "PRIMARY" >| < K_RIGHT : "RIGHT" >| < K_ROW : "ROW" >| < K_ROWS : "ROWS" >| < K_SELECT : "SELECT" >| < K_SET : "SET" >| < K_STRING : "STRING" >| < K_STRING_AGG : "STRING_AGG" >| < K_SUM : "SUM" >| < K_SWITCH : "SWITCH" >| < K_THEN : "THEN" >| < K_TIMESTAMP : "TIMESTAMP" >| < K_TRUE : "TRUE" >| < K_TUPLE : "TUPLE" >| < K_UNION : "UNION" >| < K_UPDATE : "UPDATE" >| < K_VALUES : "VALUES" >| < K_VARCHAR : "VARCHAR" >| < K_WHEN : "WHEN" >| < K_WHERE : "WHERE" >| < K_WITH : "WITH" >| < K_XHTML : "XHTML" >}TOKEN : /* FPL keywords (prefixed with A_) */{  < A_ACTION : "ACTION" >| < A_AJAX : "AJAX" >| < A_ASYNC : "ASYNC" >| < A_BEGIN : "BEGIN" >| < A_DECLARE : "DECLARE" >| < A_ELSIF : "ELSIF" >| < A_EXCEPTION : "EXCEPTION" >| < A_FUNCTION : "FUNCTION" >| < A_IF : "IF" >| < A_IMMUTABLE : "IMMUTABLE" >| < A_OTHERS : "OTHERS" >| < A_POST : "POST" >| < A_RAISE : "RAISE" >| < A_RETURN : "RETURN" >| < A_RETURNS : "RETURNS" >| < A_SYNC : "SYNC" >}TOKEN : /* non-reserved keywords (prefixed with NK_) */{  < NK_ASC : "ASC" >| < NK_CHARACTER_LENGTH : "CHARACTER_LENGTH" >| < NK_CHAR_LENGTH : "CHAR_LENGTH" >| < NK_COALESCE : "COALESCE" >| < NK_DESC : "DESC" >| < NK_FIRST : "FIRST" >| < NK_LAST : "LAST" >| < NK_LOWER : "LOWER" >| < NK_MOD : "MOD" >| < NK_NEXT : "NEXT" >| < NK_NULLS : "NULLS" >| < NK_SUBSTRING : "SUBSTRING" >| < NK_UPPER : "UPPER" >| < NK_POSITION : "POSITION" >}// When in the IN_LITERAL state, no character is skipped
< IN_LITERAL >TOKEN :{  < #L_NONQUOTE_CHARACTER : ~[ "'" ] >| < #L_QUOTE_SYMBOL : "''" >| < END_QUOTE : "'" > : DEFAULT}TOKEN : /* literals (prefixed with L_) */{  < L_CHARACTER_STRING_LITERAL :    < C_QUOTE >    (      < L_NONQUOTE_CHARACTER >    | < L_QUOTE_SYMBOL >    )*    < END_QUOTE >>| < L_SIGN :    < C_PLUS_SIGN >  | < C_MINUS_SIGN >>| < #L_UNSIGNED_INTEGER : (< C_DIGIT >)+ >| < L_EXACT_NUMERIC_LITERAL :    < L_UNSIGNED_INTEGER >    (      < C_PERIOD > (< L_UNSIGNED_INTEGER >)?    )?  | < C_PERIOD > < L_UNSIGNED_INTEGER >>| < L_APPROXIMATE_NUMERIC_LITERAL : < L_EXACT_NUMERIC_LITERAL > "E" (< L_SIGN >)? < L_UNSIGNED_INTEGER >>| < L_ECHAR :    "\\"    (      "t"    | "b"    | "n"    | "r"    | "f"    | "\\"    | "\""    | "'"    ) >| < L_DOUBLE_QUOTE_LITERAL :    // Double quoted string
    "\""    (      (~[ "\"", "\\", "\n", "\r" ])    | < L_ECHAR >    )*    "\"" >}TOKEN : /* SQL language identifier */{  < SQL_LANGUAGE_IDENTIFIER :    < C_SIMPLE_LATIN_LETTER >    (      < C_UNDERSCORE >    | < C_SIMPLE_LATIN_LETTER >    | < C_DIGIT >    )* >}TOKEN : /* Escaped language identifier */{  < ESCAPED_LANGUAGE_IDENTIFIER : "`" < SQL_LANGUAGE_IDENTIFIER > "`" >}TOKEN : /* Action path is an "hpath" as specified in http://www.ietf.org/rfc/rfc1738.txt */{  < #URL_SAFE : "$" // | "-" interferes with query parser    // | "_" interferes with query parser    // | "." interferes with query parser    // | "+" interferes with query parser
    >| < #URL_EXTRA : "!" // | "*" interferes with query parser    // | "'" interferes with query parser    // | "(" interferes with query parser    // | ")" interferes with query parser
    // | "," interferes with query parser
    >| < #URL_UCHAR : < URL_UNRESERVED >>| < #URL_UNRESERVED :    [ "a"-"z", "A"-"Z" ]  | [ "0"-"9" ]  | < URL_SAFE >  | < URL_EXTRA >>| < #URL_HSEGMENT :    (      < URL_UCHAR >      // | ";" interferes with query parser      // | ":" interferes with query parser    | "@"    | "&"      // | "=" interferes with query parser    )+ >| < URL_HPATH : < URL_HSEGMENT > ("/" < URL_HSEGMENT >)* >}ScalarLiteral literal() throws QueryParsingException :{  ScalarLiteral result;}{  (    result = signed_numeric_literal()  | result = general_literal()  )  {    return result;  }}ScalarLiteral unsigned_literal() throws QueryParsingException :{  ScalarLiteral result;}{  (    result = unsigned_numeric_literal(null)  | result = general_literal()  )  {    return result;  }}ScalarLiteral general_literal() throws QueryParsingException :{  Token token;  boolean literal;  ScalarLiteral result;}{  (    token = < L_CHARACTER_STRING_LITERAL >    {      Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);      result = new StringLiteral(token.image, location);    }  | result = boolean_literal()  )  {    return result;  }}NumericLiteral signed_numeric_literal() throws QueryParsingException :{  NumericLiteral result;  Token sign = null;}{  [ sign = < L_SIGN > ] result = unsigned_numeric_literal(sign)  {    return result;  }}NumericLiteral unsigned_numeric_literal(Token sign) throws QueryParsingException :{  NumericLiteral result = null;  Token token;  Location location;}{  (    token = < L_EXACT_NUMERIC_LITERAL >  | token = < L_APPROXIMATE_NUMERIC_LITERAL >  )  {    if (sign != null)    {      location = new LocationImpl(sign, m_path, m_offset_line, m_offset_column);      result = new NumericLiteral(sign.image + token.image, location);    }    else    {      location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);      result = new NumericLiteral(token.image, location);    }    return result;  }}BooleanLiteral boolean_literal() throws QueryParsingException :{  Token token = null;  BooleanLiteral result = null;  Location location;}{  token = < K_TRUE >  {    location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    result = new BooleanLiteral(true, location);    return result;  }| token = < K_FALSE >  {    location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    result = new BooleanLiteral(false, location);    return result;  }}Token identifier() throws QueryParsingException :{  Token token;}{  (    token = < SQL_LANGUAGE_IDENTIFIER >  | token = < ESCAPED_LANGUAGE_IDENTIFIER >    {      String identifier = token.image.toString();      token.image = identifier.substring(1, identifier.length() - 1);    }  )  {    return token;  }}AttributeReference data_object_name() throws QueryParsingException :{  Token source, object;}{  source = data_source_name() < C_PERIOD > object = identifier()  {    Location location = new LocationImpl(source, object, m_path, m_offset_line, m_offset_column);    List < String > steps = new ArrayList < String > ();    steps.add(source.image);    steps.add(object.image);    return new AttributeReference(steps, location);  }}Token data_source_name() throws QueryParsingException :{  Token name;}{  name = identifier()  {    return name;  }}Token qualified_identifier() throws QueryParsingException :{  Token name;}{  name = identifier()  {    return name;  }}Token column_name() throws QueryParsingException :{  Token name;}{  name = identifier()  {    return name;  }}Token correlation_name() throws QueryParsingException :{  Token name;}{  name = identifier()  {    return name;  }}/////////////////////////////////////////////////////////////////////
// 6 SCALAR EXPRESSIONS
/////////////////////////////////////////////////////////////////////
Type data_type(String attrName, TupleType tupleType, CollectionType closestCollectionType, CreateStatement createStatement) throws QueryParsingException :{  Type type;}{  (    type = predefined_type()  | type = collection_definition(attrName, tupleType, createStatement)  | type = tuple_definition    (      attrName, tupleType, new TupleType(), closestCollectionType, createStatement    )  | type = switch_definition(attrName, tupleType, closestCollectionType, createStatement)  )  {    return type;  }}Type predefined_type() throws QueryParsingException :{  TypeEnum typeEnum;}{  (    typeEnum = character_string_type()  | typeEnum = numeric_type()  | typeEnum = boolean_type()  | typeEnum = datetime_type()  )  {    return typeEnum.get();  }}TypeEnum character_string_type() throws QueryParsingException :{}{  < K_STRING >  {    return TypeEnum.STRING;  }| < K_VARCHAR >  {    return TypeEnum.STRING;  }| < K_XHTML >  {    return TypeEnum.XHTML;  }}TypeEnum numeric_type() throws QueryParsingException :{  TypeEnum type;}{  (    type = exact_numeric_type()  | type = approximate_numeric_type()  )  {    return type;  }}TypeEnum exact_numeric_type() throws QueryParsingException :{}{  < K_DECIMAL >  {    return TypeEnum.DECIMAL;  }| < K_INTEGER >  {    return TypeEnum.INTEGER;  }| < K_LONG >  {    return TypeEnum.LONG;  }}TypeEnum approximate_numeric_type() throws QueryParsingException :{}{  < K_DOUBLE >  {    return TypeEnum.DOUBLE;  }| < K_FLOAT >  {    return TypeEnum.FLOAT;  }}TypeEnum boolean_type() throws QueryParsingException :{}{  < K_BOOLEAN >  {    return TypeEnum.BOOLEAN;  }}TypeEnum datetime_type() throws QueryParsingException :{}{  < K_DATE >  {    return TypeEnum.DATE;  }| < K_TIMESTAMP >  {    return TypeEnum.TIMESTAMP;  }}ValueExpression value_expression_primary() throws QueryParsingException :{  ValueExpression result;}{  (    LOOKAHEAD(nonparenthesized_value_expression_primary())    result = nonparenthesized_value_expression_primary()  | result = parenthesized_value_expression()  )  {    return result;  }}ValueExpression parenthesized_value_expression() throws QueryParsingException :{  ValueExpression result;}{  < C_LEFT_PAREN > result = value_expression() < C_RIGHT_PAREN >  {    return result;  }}ValueExpression nonparenthesized_value_expression_primary() throws QueryParsingException :{  ValueExpression result;  Token token;}{  (    LOOKAHEAD(set_function_specification())    result = set_function_specification()  | result = subquery()  | result = case_expression()  | LOOKAHEAD([ < K_INLINE > ] < K_SWITCH >)    result = switch_value_constructor()  | result = cast_specification()  | LOOKAHEAD(tuple_value_constructor())    result = tuple_value_constructor()  | LOOKAHEAD(collection_value_constructor())    result = collection_value_constructor()  | LOOKAHEAD(routine_invocation())    result = routine_invocation()  | result = unsigned_value_specification()  | result = identifier_chain()  | token = < K_NULL >    {      Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);      result = new NullLiteral(location);    }  )  {    return result;  }}ValueExpression unsigned_value_specification() throws QueryParsingException :{  ValueExpression result;}{  result = unsigned_literal()  {    return result;  }}AttributeReference identifier_chain() throws QueryParsingException :{  List < String > path = new ArrayList < String > ();  Token start = null;  Token end = null;}{  start = identifier()  {    path.add(start.image);    end = start;  }  (    LOOKAHEAD(2) // To differentiate between a period followed by an identifier or an asterisk (see qualified_asterisk production).
    < C_PERIOD > end = identifier()    {      path.add(end.image);    }  )*  {    Location location = new LocationImpl(start, end, m_path, m_offset_line, m_offset_column);    AttributeReference attrRef = new AttributeReference(path, location);    return attrRef;  }}AggregateFunctionNode set_function_specification() throws QueryParsingException :{  AggregateFunctionNode result;}{  result = aggregate_function()  {    return result;  }}CaseFunctionNode case_expression() throws QueryParsingException :{  CaseFunctionNode result;}{  (    result = case_abbreviation()  | result = case_specification()  )  {    return result;  }}CaseFunctionNode case_abbreviation() throws QueryParsingException :{  GeneralFunctionNode isNullFuncNode, notFuncNode;  ValueExpression expr = null;  CaseFunctionNode funcNode;  Token token = null;  Location location;}{  token = < NK_COALESCE > < C_LEFT_PAREN > expr = value_expression()  {    location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    isNullFuncNode = new GeneralFunctionNode(IsNullFunction.NAME, location);    isNullFuncNode.addArgument((ValueExpression) expr.copy());    notFuncNode = new GeneralFunctionNode(NotFunction.NAME, location);    notFuncNode.addArgument(isNullFuncNode);    funcNode = new CaseFunctionNode(location);    funcNode.addArgument(notFuncNode);    funcNode.addArgument(expr);  }  (    < C_COMMA > expr = value_expression()    {      location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);      isNullFuncNode = new GeneralFunctionNode(IsNullFunction.NAME, location);      isNullFuncNode.addArgument((ValueExpression) expr.copy());      notFuncNode = new GeneralFunctionNode(NotFunction.NAME, location);      notFuncNode.addArgument(isNullFuncNode);      funcNode.addArgument(notFuncNode);      funcNode.addArgument(expr);    }  )*  < C_RIGHT_PAREN >  {    // Remove the last two arguments and add them as an else item
    List < ValueExpression > args = funcNode.getArguments();    ValueExpression last_arg = args.get(args.size() - 1);    ValueExpression next_to_last_arg = args.get(args.size() - 2);    funcNode.removeArgument(last_arg);    funcNode.removeArgument(next_to_last_arg);    location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    funcNode.addArgument(new BooleanLiteral(true, location));    funcNode.addArgument(last_arg);    return funcNode;  }}CaseFunctionNode case_specification() throws QueryParsingException :{  CaseFunctionNode result;}{  result = searched_case()  {    return result;  }}CaseFunctionNode searched_case() throws QueryParsingException :{  OptionItem whenItem = null;  OptionItem elseItem = null;  CaseFunctionNode funcNode;  Token token = null;}{  token = < K_CASE >  {    Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    funcNode = new CaseFunctionNode(location);  }  (    (      whenItem = searched_when_clause()      {        funcNode.addArgument((ValueExpression) whenItem.getWhenExpression().copy());        funcNode.addArgument((ValueExpression) whenItem.getThenExpression().copy());      }    )+    [      elseItem = else_clause()      {        funcNode.addArgument((ValueExpression) elseItem.getWhenExpression().copy());        funcNode.addArgument((ValueExpression) elseItem.getThenExpression().copy());      }    ]  )  < K_END >  {    return funcNode;  }}OptionItem searched_when_clause() throws QueryParsingException :{  ValueExpression whenExpr = null;  ValueExpression thenExpr = null;  Token token;}{  token = < K_WHEN > whenExpr = search_condition() < K_THEN > thenExpr = value_expression()  {    Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    return new OptionItem(whenExpr, thenExpr, location);  }}OptionItem else_clause() throws QueryParsingException :{  ValueExpression elseExpr = null;  Token token;}{  token = < K_ELSE > elseExpr = value_expression()  {    Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    return new OptionItem(new BooleanLiteral(true, location), elseExpr, location);  }}SwitchNode switch_value_constructor() throws QueryParsingException :{  SwitchNode switchNode;  boolean inline = false;  OptionItem whenItem = null;  OptionItem elseItem = null;  Token token, alias = null;}{  [    < K_INLINE >    {      inline = true;    }  ]  token = < K_SWITCH >  {    Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    switchNode = new SwitchNode(location);    switchNode.setInline(inline);  }  (    (      whenItem = searched_when_clause()      {        switchNode.addOptionItem(whenItem);      }      [        alias = as_clause()        {          whenItem.setAlias(alias.image);        }      ]    )+    [      elseItem = else_clause()      {        switchNode.addOptionItem(elseItem);      }      [        alias = as_clause()        {          elseItem.setAlias(alias.image);        }      ]    ]  )  < K_END >  {    return switchNode;  }}CastFunctionNode cast_specification() throws QueryParsingException :{  ValueExpression arg;  TypeEnum type_enum;  Type type;  Token token = null;}{  token = < K_CAST > < C_LEFT_PAREN > arg = value_expression() < K_AS >  (    type = predefined_type()    {      type_enum = TypeEnum.getEntry(type);    }  | < K_COLLECTION >    {      type_enum = TypeEnum.COLLECTION;    }  | < K_TUPLE >    {      type_enum = TypeEnum.TUPLE;    }  )  < C_RIGHT_PAREN >  {    Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    CastFunctionNode result = new CastFunctionNode(arg, type_enum.getName(), location);    return result;  }}ValueExpression value_expression() throws QueryParsingException :{  ValueExpression expr;}{  expr = boolean_value_expression()  {    return expr;  }}ValueExpression common_value_expression() throws QueryParsingException :{  ValueExpression expr;}{  expr = string_value_expression()  {    return expr;  }}ValueExpression numeric_value_expression() throws QueryParsingException :{  ValueExpression right, result;  Token token = null;  String op;}{  result = term()  (    LOOKAHEAD(2)    (      token = < C_PLUS_SIGN >      {        op = AddFunction.NAME;      }    | token = < C_MINUS_SIGN >      {        op = SubFunction.NAME;      }    )    right = term()    {      Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);      GeneralFunctionNode funcNode = new GeneralFunctionNode(op, location);      funcNode.addArgument(result);      funcNode.addArgument(right);      result = funcNode;    }  )*  {    return result;  }}ValueExpression term() throws QueryParsingException :{  ValueExpression right, result;  String op;  Token token;}{  result = factor()  (    (      token = < C_ASTERISK >      {        op = MultFunction.NAME;      }    | token = < C_SOLIDUS >      {        op = DivFunction.NAME;      }    )    right = factor()    {      Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);      GeneralFunctionNode funcNode = new GeneralFunctionNode(op, location);      funcNode.addArgument(result);      funcNode.addArgument(right);      result = funcNode;    }  )*  {    return result;  }}ValueExpression factor() throws QueryParsingException :{  ValueExpression result;  String op = "";  Token token = null;}{  [    token = < C_PLUS_SIGN >  | token = < C_MINUS_SIGN >    {      op = "NEG";    }  ]  result = numeric_primary()  {    if (op.equals("NEG"))    {      Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);      GeneralFunctionNode funcNode = new GeneralFunctionNode(NegFunction.NAME, location);      funcNode.addArgument(result);      result = funcNode;    }    return result;  }}ValueExpression numeric_primary() throws QueryParsingException :{  ValueExpression expr;}{  (    expr = numeric_value_function()  | expr = value_expression_primary()  )  {    return expr;  }}ValueExpression numeric_value_function() throws QueryParsingException :{  ValueExpression expr;}{  (    expr = modulus_expression()  | expr = length_expression()  | expr = substring_position_function()  )  {    return expr;  }}GeneralFunctionNode length_expression() throws QueryParsingException :{  ValueExpression expr = null;  GeneralFunctionNode funcNode;  Token token = null;}{  (    token = < NK_CHAR_LENGTH >  | token = < NK_CHARACTER_LENGTH >  )  < C_LEFT_PAREN > expr = string_value_expression() < C_RIGHT_PAREN >  {    Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    funcNode = new GeneralFunctionNode(LengthFunction.NAME, location);    funcNode.addArgument(expr);    return funcNode;  }}GeneralFunctionNode modulus_expression() throws QueryParsingException :{  ValueExpression dividend = null;  ValueExpression divisor = null;  GeneralFunctionNode funcNode;  Token token = null;}{  token = < NK_MOD > < C_LEFT_PAREN > dividend = numeric_value_expression() < C_COMMA > divisor = numeric_value_expression() < C_RIGHT_PAREN >  {    Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    funcNode = new GeneralFunctionNode(ModFunction.NAME, location);    funcNode.addArgument(dividend);    funcNode.addArgument(divisor);    return funcNode;  }}GeneralFunctionNode substring_position_function() throws QueryParsingException :{  ValueExpression substring_expr;  ValueExpression in_expr;  Token token = null;}{  token = < NK_POSITION > < C_LEFT_PAREN > substring_expr = character_value_expression() < K_IN > in_expr = character_value_expression() < C_RIGHT_PAREN >  {    Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    GeneralFunctionNode funcNode = new GeneralFunctionNode(PositionFunction.NAME, location);    funcNode.addArgument(substring_expr);    funcNode.addArgument(in_expr);    return funcNode;  }}ValueExpression string_value_expression() throws QueryParsingException :{  ValueExpression expr;}{  expr = character_value_expression()  {    return expr;  }}ValueExpression character_value_expression() throws QueryParsingException :{  List < ValueExpression > args = new ArrayList < ValueExpression > ();  ValueExpression expr;  Token token = null;}{  expr = character_factor()  {    args.add(expr);  }  (    token = < DT_CONCATENATION_OPERATOR > expr = character_factor()    {      args.add(expr);    }  )*  {    if (args.size() > 1)    {      Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);      GeneralFunctionNode funcNode = new GeneralFunctionNode(ConcatFunction.NAME, args, location);      return funcNode;    }    else    {      return args.get(0);    }  }}ValueExpression character_factor() throws QueryParsingException :{  ValueExpression expr;}{  expr = character_primary()  {    return expr;  }}ValueExpression character_primary() throws QueryParsingException :{  ValueExpression expr;}{  (    expr = numeric_value_expression()  | expr = string_value_function()  )  {    return expr;  }}ValueExpression string_value_function() throws QueryParsingException :{  ValueExpression expr;}{  expr = character_value_function()  {    return expr;  }}ValueExpression character_value_function() throws QueryParsingException :{  ValueExpression expr;}{  (    expr = character_substring_function()  | expr = fold()  )  {    return expr;  }}ValueExpression character_substring_function() throws QueryParsingException :{  ValueExpression expr, from_position, for_length = null;  Token token = null;}{  token = < NK_SUBSTRING > < C_LEFT_PAREN > expr = character_value_expression() < K_FROM > from_position = numeric_value_expression() [ < K_FOR > for_length = numeric_value_expression() ] < C_RIGHT_PAREN >  {    Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    GeneralFunctionNode funcNode = new GeneralFunctionNode(SubstringFunction.NAME, location);    funcNode.addArgument(expr);    funcNode.addArgument(from_position);    if (for_length != null)    {      funcNode.addArgument(for_length);    }    return funcNode;  }}ValueExpression fold() throws QueryParsingException :{  String func;  ValueExpression expr;  Token token = null;}{  (    token = < NK_UPPER >    {      func = UpperFunction.NAME;    }  | token = < NK_LOWER >    {      func = LowerFunction.NAME;    }  )  < C_LEFT_PAREN > expr = character_value_expression() < C_RIGHT_PAREN >  {    Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    GeneralFunctionNode funcNode = new GeneralFunctionNode(func, location);    funcNode.addArgument(expr);    return funcNode;  }}ValueExpression boolean_value_expression() throws QueryParsingException :{  ValueExpression result, right;  Token token = null;}{  result = boolean_term()  (    token = < K_OR > right = boolean_term()    {      Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);      GeneralFunctionNode funcNode = new GeneralFunctionNode(OrFunction.NAME, location);      funcNode.addArgument(result);      funcNode.addArgument(right);      result = funcNode;    }  )*  {    return result;  }}ValueExpression boolean_term() throws QueryParsingException :{  ValueExpression result, right;  Token token = null;}{  result = boolean_factor()  (    token = < K_AND > right = boolean_factor()    {      Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);      GeneralFunctionNode funcNode = new GeneralFunctionNode(AndFunction.NAME, location);      funcNode.addArgument(result);      funcNode.addArgument(right);      result = funcNode;    }  )*  {    return result;  }}ValueExpression boolean_factor() throws QueryParsingException :{  ValueExpression result;  Token token = null;}{  (    result = boolean_test()  |    (      token = < K_NOT > result = boolean_test()      {        Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);        GeneralFunctionNode funcNode = new GeneralFunctionNode(NotFunction.NAME, location);        funcNode.addArgument(result);        result = funcNode;      }    )  )  {    return result;  }}ValueExpression boolean_test() throws QueryParsingException :{  ValueExpression result;  boolean negate = false;  BooleanLiteral truthValue = null;  Token token;}{  result = boolean_primary()  [    token = < K_IS >    [      < K_NOT >      {        negate = true;      }    ]    truthValue = boolean_literal()    {      Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);      GeneralFunctionNode funcNode = new GeneralFunctionNode(EqualFunction.NAME, location);      funcNode.addArgument(result);      if (negate)      {        truthValue = new BooleanLiteral(!truthValue.getScalarValue().getObject().booleanValue(), truthValue.getLocation());      }      funcNode.addArgument(truthValue);      result = funcNode;    }  ]  {    return result;  }}ValueExpression boolean_primary() throws QueryParsingException :{  ValueExpression result;}{  result = predicate()  {    return result;  }}/////////////////////////////////////////////////////////////////////
// 7 QUERY EXPRESSIONS
/////////////////////////////////////////////////////////////////////
TupleFunctionNode tuple_value_constructor() throws QueryParsingException :{  TupleFunctionNode funcNode;  Token alias = null;  QueryConstruct argument = null;  Token token;  boolean inline = false;}{  (    LOOKAHEAD(2)    [      < K_INLINE >      {        inline = true;      }    ]    token = < K_TUPLE > < C_LEFT_PAREN >    {      Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);      funcNode = new TupleFunctionNode(location);      funcNode.setInline(inline);    }    (      < C_RIGHT_PAREN >      {        return funcNode;      }    | argument = tuple_sublist()      {        funcNode.addArgument(argument);      }      (        < C_COMMA > argument = tuple_sublist()        {          funcNode.addArgument(argument);        }      )*      < C_RIGHT_PAREN >      {        return funcNode;      }    )  |    (      [        < K_INLINE >        {          inline = true;        }      ]      token = < C_LEFT_BRACE >      {        Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);        funcNode = new TupleFunctionNode(location);        funcNode.setInline(inline);      }      (        < C_RIGHT_BRACE >        {          return funcNode;        }      | argument = tuple_sublist()        {          funcNode.addArgument(argument);        }        (          < C_COMMA > argument = tuple_sublist()          {            funcNode.addArgument(argument);          }        )*        < C_RIGHT_BRACE >      )      {        return funcNode;      }    )  )}CollectionFunctionNode collection_value_constructor()throws QueryParsingException :{  CollectionFunctionNode funcNode;  ValueExpression argument = null;  Token token;  Location location;}{  (    LOOKAHEAD(2)    (      token = < K_BAG > < C_LEFT_PAREN >      {        location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);        funcNode = new CollectionFunctionNode(location);        funcNode.setOrdered(false);        funcNode.setLocation(location);      }    | token = < K_LIST > < C_LEFT_PAREN >      {        location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);        funcNode = new CollectionFunctionNode(location);        funcNode.setOrdered(true);        funcNode.setLocation(location);      }    )    (      < C_RIGHT_PAREN >      {        return funcNode;      }    | argument = value_expression()      {        funcNode.addArgument(argument);      }      (        < C_COMMA > argument = value_expression()        {          funcNode.addArgument(argument);        }      )*      < C_RIGHT_PAREN >      {        return funcNode;      }    )  |    (      (        token = < C_LEFT_BRACE > < C_LEFT_BRACE >        {          location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);          funcNode = new CollectionFunctionNode(location);          funcNode.setOrdered(false);          funcNode.setLocation(location);        }        (          < C_RIGHT_BRACE > < C_RIGHT_BRACE >          {            return funcNode;          }        | argument = value_expression()          {            funcNode.addArgument(argument);          }          (            < C_COMMA > argument = value_expression()            {              funcNode.addArgument(argument);            }          )*          < C_RIGHT_BRACE > < C_RIGHT_BRACE >        )        {          return funcNode;        }      | token = < C_LEFT_BRACKET >        {          location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);          funcNode = new CollectionFunctionNode(location);          funcNode.setOrdered(true);          funcNode.setLocation(location);        }        (          < C_RIGHT_BRACKET >          {            return funcNode;          }        | argument = value_expression()          {            funcNode.addArgument(argument);          }          (            < C_COMMA > argument = value_expression()            {              funcNode.addArgument(argument);            }          )*          < C_RIGHT_BRACKET >        )        {          return funcNode;        }      )    )  )}QueryConstruct tuple_sublist() throws QueryParsingException :{  QueryConstruct item;}{  (    LOOKAHEAD(tuple_all_item()) // To differentiate between an identifier followed by a period and an asterisk, or an optional as_clause production.
    item = tuple_all_item()  | item = tuple_item()  )  {    return item;  }}TupleItem tuple_item() throws QueryParsingException :{  Token alias = null;  ValueExpression expression = null;}{  (    LOOKAHEAD(2)    alias = column_name() < C_COLON > expression = value_expression()  | expression = value_expression() alias = as_clause()  )  {    Location location = new LocationImpl(alias, m_path, m_offset_line, m_offset_column);    return new TupleItem(expression, alias.image, expression.getLocation());  }}TupleAllItem tuple_all_item() throws QueryParsingException :{  AttributeReference attrRef;  Token token;}{  attrRef = identifier_chain() < C_PERIOD > token = < C_ASTERISK >  {    TupleAllItem tuple_item = new TupleAllItem(attrRef, attrRef.getLocation());    tuple_item.getLocation().setEndLine(token.endLine);    tuple_item.getLocation().setEndColumn(token.endColumn);    return tuple_item;  }}List < ValueExpression > contextually_typed_row_value_constructor() throws QueryParsingException :{  List < ValueExpression > expressions = new ArrayList < ValueExpression > ();  ValueExpression expression = null;}{  < C_LEFT_PAREN > expression = contextually_typed_row_value_constructor_element()  {    expressions.add(expression);  }  (    < C_COMMA > expression = contextually_typed_row_value_constructor_element()    {      expressions.add(expression);    }  )*  < C_RIGHT_PAREN >  {    return expressions;  }}ValueExpression contextually_typed_row_value_constructor_element() throws QueryParsingException :{  ValueExpression expression = null;}{  (    expression = value_expression()  )  {    return expression;  }}List < ValueExpression > contextually_typed_row_value_expression() throws QueryParsingException :{  List < ValueExpression > expressions = null;}{  (    expressions = contextually_typed_row_value_constructor()  )  {    return expressions;  }}List < ValueExpression > contextually_typed_table_value_constructor() throws QueryParsingException :{  List < ValueExpression > expressions = new ArrayList < ValueExpression > ();}{  < K_VALUES > expressions = contextually_typed_row_value_expression_list()  {    return expressions;  }}List < ValueExpression > contextually_typed_row_value_expression_list() throws QueryParsingException :{  List < ValueExpression > expressions = null;}{  expressions = contextually_typed_row_value_expression()  {    return expressions;  }}void table_expression(QuerySpecification query_specification) throws QueryParsingException :{}{  [ from_clause(query_specification) ]   [ where_clause(query_specification) ]   [ group_by_clause(query_specification) ]   [ having_clause(query_specification) ]}void from_clause(QuerySpecification query_specification) throws QueryParsingException :{  List < FromItem > fromItems = null;}{  < K_FROM > fromItems = table_reference_list()  {    query_specification.setFromItems(fromItems);  }}List < FromItem > table_reference_list() throws QueryParsingException :{  List < FromItem > fromItemsList = new ArrayList < FromItem > ();  FromItem fromItem = null;}{  fromItem = table_reference()  {    fromItemsList.add(fromItem);  }  (    LOOKAHEAD(2)    < C_COMMA > fromItem = table_reference()    {      fromItemsList.add(fromItem);    }  )*  {    return fromItemsList;  }}FromItem table_reference() throws QueryParsingException :{  FromItem fromItem = null;}{  fromItem = table_primary() [ fromItem = joined_table_right(fromItem) ]  {    return fromItem;  }}FromItem table_primary() throws QueryParsingException :{  Token alias = null;  Token position_variable = null;  ValueExpression valueExpr = null;  FromItem fromItem = null;}{  ( LOOKAHEAD(routine_invocation()) // Distinguish "some.function()" from "some.table"    (      valueExpr = routine_invocation()      {        fromItem = new FromExpressionItem(valueExpr, valueExpr.getLocation());      }      [        < K_AT > position_variable = identifier()        {          ((FromExpressionItem) fromItem).setInputOrderVariable(position_variable.image);          fromItem.getLocation().setEndLine(position_variable.endLine);          fromItem.getLocation().setEndColumn(position_variable.endColumn);        }      ]      [ < K_AS > ] alias = correlation_name()      {        ((FromExpressionItem) fromItem).setAlias(alias.image);        fromItem.getLocation().setEndLine(alias.endLine);        fromItem.getLocation().setEndColumn(alias.endColumn);      }    )  |    (      valueExpr = identifier_chain()      {        fromItem = new FromExpressionItem(valueExpr, valueExpr.getLocation());      }      [        < K_AT > position_variable = identifier()        {          ((FromExpressionItem) fromItem).setInputOrderVariable(position_variable.image);          fromItem.getLocation().setEndLine(position_variable.endLine);          fromItem.getLocation().setEndColumn(position_variable.endColumn);        }      ]      [        [ < K_AS > ] alias = correlation_name()        {          ((FromExpressionItem) fromItem).setAlias(alias.image);          fromItem.getLocation().setEndLine(alias.endLine);          fromItem.getLocation().setEndColumn(alias.endColumn);        }      ]    )  | LOOKAHEAD(subquery()) // Distinguish parentheses of subquery from parenthese from join items    (      valueExpr = subquery()      {        fromItem = new FromExpressionItem(valueExpr, valueExpr.getLocation());      }      (        < K_AT > position_variable = identifier() < K_AS > alias = correlation_name()        {          ((FromExpressionItem) fromItem).setInputOrderVariable(position_variable.image);        }      | [ < K_AS > ] alias = correlation_name()      )      {        ((FromExpressionItem) fromItem).setAlias(alias.image);        fromItem.getLocation().setEndLine(alias.endLine);        fromItem.getLocation().setEndColumn(alias.endColumn);      }    )  |    (      {        JoinType flatten_type;        AttributeReference attr_ref;        FromItem left;        FromExpressionItem right;        Token token;      }      (        token = < K_OUTER > < K_FLATTEN >        {          flatten_type = JoinType.LEFT_OUTER;        }      | token = < K_INNER > < K_FLATTEN >        {          flatten_type = JoinType.INNER;        }      | token = < K_FLATTEN >        {          flatten_type = JoinType.INNER;        }      )      < C_LEFT_PAREN > left = table_primary() < C_COMMA > attr_ref = identifier_chain() [ < K_AS > ] alias = correlation_name() < C_RIGHT_PAREN >      {        right = new FromExpressionItem(attr_ref, attr_ref.getLocation());        right.setAlias(alias.image);        Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);        fromItem = new FlattenItem(left, right, flatten_type, location);        fromItem.getLocation().setEndLine(alias.endLine);        fromItem.getLocation().setEndColumn(alias.endColumn);      }    )  |    (      valueExpr = collection_value_constructor()      {        fromItem = new FromExpressionItem(valueExpr, valueExpr.getLocation());      }      (        < K_AT > position_variable = identifier() < K_AS > alias = correlation_name()        {          ((FromExpressionItem) fromItem).setInputOrderVariable(position_variable.image);        }      | [ < K_AS > ] alias = correlation_name()      )      {        ((FromExpressionItem) fromItem).setAlias(alias.image);        fromItem.getLocation().setEndLine(alias.endLine);        fromItem.getLocation().setEndColumn(alias.endColumn);      }    )  | fromItem = parenthesized_joined_table()  )  {    return fromItem;  }}List < String > column_name_list() throws QueryParsingException :{  List < String > columnNameList = new ArrayList < String > ();  Token columnName;}{  columnName = column_name()  {    columnNameList.add(columnName.image);  }  (    < C_COMMA > columnName = column_name()    {      columnNameList.add(columnName.image);    }  )*  {    return columnNameList;  }}FromItem parenthesized_joined_table() throws QueryParsingException :{  FromItem result = null;}{  < C_LEFT_PAREN >  (    LOOKAHEAD(joined_table())    result = joined_table() [ result = joined_table_right(result) ]  | result = parenthesized_joined_table()  )  < C_RIGHT_PAREN >  {    return result;  }}FromItem joined_table() throws QueryParsingException :{  FromItem left, result;}{  left = table_primary()  (    result = cross_join(left)  | result = qualified_join(left)  | result = natural_join(left)  )  {    return result;  }}FromItem joined_table_right(FromItem left) throws QueryParsingException :{  FromItem result = null;}{  (    result = cross_join(left)  | result = qualified_join(left)  | result = natural_join(left)  )  [ result = joined_table_right(result) ]  {    return result;  }}FromItem cross_join(FromItem left) throws QueryParsingException :{  FromItem right = null;  Token token;}{  token = < K_CROSS > < K_JOIN > right = table_primary()  {    Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    return new JoinItem(left, right, JoinType.CROSS, location);  }}FromItem qualified_join(FromItem left) throws QueryParsingException :{  JoinItem joinItem = null;  JoinType type = JoinType.INNER;  FromItem right = null;  Token token;}{  [ type = join_type() ] token = < K_JOIN > right = table_reference()  {    Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    joinItem = new JoinItem(left, right, type, location);  }  join_specification(joinItem)  {    return joinItem;  }}FromItem natural_join(FromItem left) throws QueryParsingException :{  JoinType type = JoinType.INNER;  FromItem right = null;  Token token;}{  token = < K_NATURAL > [ type = join_type() ] < K_JOIN > right = table_primary()  {    Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    return new JoinItem(left, right, type, true, location);  }}void join_specification(JoinItem joinItem) throws QueryParsingException :{}{  join_condition(joinItem)}void join_condition(JoinItem joinItem) throws QueryParsingException :{  ValueExpression onCondition = null;}{  < K_ON > onCondition = search_condition()  {    joinItem.setOnCondition(onCondition);  }}JoinType join_type() throws QueryParsingException :{}{  (    < K_INNER >    {      return JoinType.INNER;    }  | < K_LEFT > [ < K_OUTER > ]    {      return JoinType.LEFT_OUTER;    }  | < K_RIGHT > [ < K_OUTER > ]    {      return JoinType.RIGHT_OUTER;    }  | < K_FULL > [ < K_OUTER > ]    {      return JoinType.FULL_OUTER;    }  )}void where_clause(QuerySpecification querySpecification) throws QueryParsingException :{  ValueExpression where = null;}{  < K_WHERE > where = search_condition()  {    querySpecification.setWhereExpression(where);  }}void group_by_clause(QuerySpecification querySpecification) throws QueryParsingException :{}{  < K_GROUP > < K_BY > grouping_element(querySpecification)  (    < C_COMMA > grouping_element(querySpecification)  )*}void grouping_element(QuerySpecification querySpecification) throws QueryParsingException :{}{  ordinary_grouping_set(querySpecification)}void ordinary_grouping_set(QuerySpecification querySpecification) throws QueryParsingException :{  GroupByItem groupByItem;}{  groupByItem = grouping_column_reference()  {    querySpecification.addGroupByItem(groupByItem);  }}GroupByItem grouping_column_reference() throws QueryParsingException :{  GroupByItem groupByItem;  ValueExpression expr = null;}{  expr = identifier_chain()  {    groupByItem = new GroupByItem(expr.getLocation());    groupByItem.setExpression(expr);    return groupByItem;  }}void having_clause(QuerySpecification querySpecification) throws QueryParsingException :{  ValueExpression havingExpr = null;}{  < K_HAVING > havingExpr = search_condition()  {    querySpecification.setHavingExpression(havingExpr);  }}QueryNode query_specification() throws QueryParsingException :{  QuerySpecification querySpecification;  SetQuantifier setQuantifier = SetQuantifier.ALL;  List < SelectItem > selectList = null;  SelectItem singleItem = null;  Token token;}{  LOOKAHEAD(2)  (    token = < K_SELECT >    {      Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);      querySpecification = new QuerySpecification(location);    }    [      setQuantifier = set_quantifier()      {        querySpecification.setSetQuantifier(setQuantifier);      }    ]    selectList = select_list() table_expression(querySpecification)    {      querySpecification.setSelectItems(selectList);      return querySpecification;    }  )|  (    token = < K_SELECT > < K_ELEMENT >    {      Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);      querySpecification = new QuerySpecification(location);      querySpecification.setSelectQualifier(QuerySpecification.SelectQualifier.ELEMENT);      selectList = new ArrayList < SelectItem > ();      ValueExpression value_expr = null;    }    [      setQuantifier = set_quantifier()      {        querySpecification.setSetQuantifier(setQuantifier);      }    ]    value_expr = value_expression() table_expression(querySpecification)    {      singleItem = new SelectExpressionItem(value_expr, location);      selectList.add(singleItem);      querySpecification.setSelectItems(selectList);      return querySpecification;    }  )}List < SelectItem > select_list() throws QueryParsingException :{  List < SelectItem > selectList = new ArrayList < SelectItem > ();  Token token;  SelectItem selectItem = null;}{  (    token = < C_ASTERISK >    {      Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);      selectItem = new SelectAllItem(location);      selectList.add(selectItem);    }  |    (      selectItem = select_sublist()      {        selectList.add(selectItem);      }      (        < C_COMMA > selectItem = select_sublist()        {          selectList.add(selectItem);        }      )*    )  )  {    return selectList;  }}SelectItem select_sublist() throws QueryParsingException :{  SelectItem selectItem = null;}{  (    LOOKAHEAD(qualified_asterisk()) // To differentiate between an identifier followed by a period and an asterisk, or an optional as_clause production.
    selectItem = qualified_asterisk()  | selectItem = derived_column()  )  {    return selectItem;  }}SelectItem qualified_asterisk() throws QueryParsingException :{  AttributeReference attrRef;  Token token;}{  attrRef = identifier_chain() < C_PERIOD > token = < C_ASTERISK >  {    SelectAllItem selectItem = new SelectAllItem(attrRef, attrRef.getLocation());    selectItem.getLocation().setEndLine(token.endLine);    selectItem.getLocation().setEndColumn(token.endColumn);    return selectItem;  }}SelectItem derived_column() throws QueryParsingException :{  Token alias = null;  SelectExpressionItem selectItem = null;  ValueExpression expression = null;}{  (    LOOKAHEAD(2) // To differentiate between an alias and a column name.
    alias = column_name() < C_COLON > expression = value_expression()    {      selectItem = new SelectExpressionItem(expression, expression.getLocation());      selectItem.setAlias(alias.image);    }  | expression = value_expression()    {      selectItem = new SelectExpressionItem(expression, expression.getLocation());    }    [      alias = as_clause()      {        selectItem.setAlias(alias.image);      }    ]  )  {    return selectItem;  }}Token as_clause() throws QueryParsingException :{  Token alias = null;}{  [ < K_AS > ] alias = column_name()  {    return alias;  }}QueryNode query_expression() throws QueryParsingException :{  QueryNode body = null;  List < OrderByItem > orderByList = null;  List < WithItem > withList = null;  ValueExpression offset = null;  ValueExpression fetch = null;}{  [ withList = with_clause() ] body = query_expression_body() [ orderByList = order_by_clause() ] [ offset = result_offset_clause() ] [ fetch = fetch_first_clause() ]  {    if (withList == null && orderByList == null && offset == null && fetch == null)    {      return body;    }    else    {      QueryExpression queryExpression = new QueryExpression(body.getLocation());      queryExpression.setBody(body);      if (withList != null)      {        queryExpression.setWithItems(withList);      }      if (orderByList != null)      {        queryExpression.setOrderByItems(orderByList);      }      if (offset != null)      {        queryExpression.setOffset(offset);      }      if (fetch != null)      {        queryExpression.setFetch(fetch);      }      return queryExpression;    }  }}List < WithItem > with_clause() throws QueryParsingException :{  List < WithItem > withList = null;}{  < K_WITH > withList = with_list()  {    return withList;  }}List < WithItem > with_list() throws QueryParsingException :{  List < WithItem > withList = new ArrayList < WithItem > ();  WithItem withItem = null;}{  withItem = with_element()  {    withList.add(withItem);  }  (    < C_COMMA > withItem = with_element()    {      withList.add(withItem);    }  )*  {    return withList;  }}WithItem with_element() throws QueryParsingException :{  QueryNode query;  Token name;}{  name = identifier() < K_AS > < C_LEFT_PAREN > query = query_expression() < C_RIGHT_PAREN >  {    return new WithItem(name.image, query, query.getLocation());  }}QueryNode query_expression_body() throws QueryParsingException :{  QueryNode query = null;  QueryNode right = null;  SetQuantifier setQuantifier = SetQuantifier.DISTINCT;  Token token;  Location location;}{  query = query_term()  [    (      token = < K_UNION > [ setQuantifier = set_quantifier() ] right = query_expression_body()      {        location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);        query = new SetOpExpression(SetOpExpression.SetOpType.UNION, setQuantifier, query, right, location);      }    )  |    (      token = < K_OUTER > < K_UNION > [ setQuantifier = set_quantifier() ] right = query_expression_body()      {        location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);        query = new SetOpExpression(SetOpExpression.SetOpType.OUTER_UNION, setQuantifier, query, right, location);      }    )  |    (      token = < K_EXCEPT > [ setQuantifier = set_quantifier() ] right = query_expression_body()      {        location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);        query = new SetOpExpression(SetOpExpression.SetOpType.EXCEPT, setQuantifier, query, right, location);      }    )  ]  {    return query;  }}QueryNode query_term() throws QueryParsingException :{  QueryNode query = null;  QueryNode right = null;  SetQuantifier setQuantifier = SetQuantifier.DISTINCT;  Token token;}{  query = query_primary()  [    token = < K_INTERSECT > [ setQuantifier = set_quantifier() ] right = query_term()    {      Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);      query = new SetOpExpression(SetOpExpression.SetOpType.INTERSECT, setQuantifier, query, right, location);    }  ]  {    return query;  }}QueryNode query_primary() throws QueryParsingException :{  QueryNode query = null;}{  query = simple_table()  {    return query;  }| < C_LEFT_PAREN > query = query_expression() < C_RIGHT_PAREN >  {    return query;  }}QueryNode simple_table() throws QueryParsingException :{  QueryNode query = null;}{  query = query_specification()  {    return query;  }}List < OrderByItem > order_by_clause() throws QueryParsingException :{  List < OrderByItem > orderByList = null;}{  < K_ORDER > < K_BY > orderByList = sort_specification_list()  {    return orderByList;  }}ValueExpression result_offset_clause() throws QueryParsingException :{  ValueExpression expr;  Token offsetToken;}{  offsetToken = < K_OFFSET > expr = offset_row_count()  (    < K_ROW >  | < K_ROWS >  )  {    expr.setLocation(new LocationImpl(offsetToken, m_path, m_offset_line, m_offset_column));    return expr;  }}ValueExpression fetch_first_clause() throws QueryParsingException :{  ValueExpression expr;  Token fetchToken;}{  (    (      fetchToken = < K_FETCH >      (        < NK_FIRST >      | < NK_NEXT >      )      expr = fetch_first_quantity()      (        < K_ROW >      | < K_ROWS >      )      < K_ONLY >    )  |    (      fetchToken = < K_LIMIT > expr = fetch_first_quantity()    )  )  {    expr.setLocation(new LocationImpl(fetchToken, m_path, m_offset_line, m_offset_column));    return expr;  }}ValueExpression fetch_first_quantity() throws QueryParsingException :{  ValueExpression expr;}{  expr = fetch_first_row_count()  {    return expr;  }}ValueExpression offset_row_count() throws QueryParsingException :{  ValueExpression expr;}{  expr = value_expression()  {    return expr;  }}ValueExpression fetch_first_row_count() throws QueryParsingException :{  ValueExpression expr;}{  expr = value_expression()  {    return expr;  }}QueryNode subquery() throws QueryParsingException :{  QueryNode query = null;}{  < C_LEFT_PAREN > query = query_expression() < C_RIGHT_PAREN >  {    return query;  }}/////////////////////////////////////////////////////////////////////
// 8 PREDICATES
/////////////////////////////////////////////////////////////////////
ValueExpression predicate() throws QueryParsingException :{  ValueExpression result;}{  (    result = exists_predicate()  | result = common_value_expression()    [      LOOKAHEAD(3) // To differentiate between IS [ NOT ] NULL and IS [ NOT ] (TRUE | FALSE) (see boolean_test production).
      (        result = comparison_predicate(result)      | result = like_predicate(result)      | result = null_predicate(result)      )    ]  )  {    return result;  }}ValueExpression comparison_predicate(ValueExpression left) throws QueryParsingException :{  GeneralFunctionNode funcNode;  ValueExpression right;  Class <? extends Function > op;}{  funcNode = comp_op() right = common_value_expression()  {    funcNode.addArgument(left);    funcNode.addArgument(right);    left = funcNode;  }  {    return left;  }}GeneralFunctionNode comp_op() throws QueryParsingException :{  String op;  Token token = null;}{  (    token = < C_EQUALS_OPERATOR >    {      op = EqualFunction.NAME;    }  | token = < DT_NOT_EQUALS_OPERATOR >    {      op = NotEqualFunction.NAME;    }  | token = < C_LESS_THAN_OPERATOR >    {      op = LessThanFunction.NAME;    }  | token = < C_GREATER_THAN_OPERATOR >    {      op = GreaterThanFunction.NAME;    }  | token = < DT_LESS_THAN_OR_EQUALS_OPERATOR >    {      op = LessEqualFunction.NAME;    }  | token = < DT_GREATER_THAN__OR_EQUALS_OPERATOR >    {      op = GreaterEqualFunction.NAME;    }  )  {    Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    GeneralFunctionNode funcNode = new GeneralFunctionNode(op, location);    return funcNode;  }}ValueExpression like_predicate(ValueExpression left) throws QueryParsingException :{  ValueExpression result;  boolean negate = false;  Token likeToken, notToken = null;  Location location;}{  [    notToken = < K_NOT >    {      negate = true;    }  ]  likeToken = < K_LIKE > result = character_value_expression()  {    location = new LocationImpl(likeToken, m_path, m_offset_line, m_offset_column);    GeneralFunctionNode funcNode = new GeneralFunctionNode(LikeFunction.NAME, location);    funcNode.addArgument(left);    funcNode.addArgument(result);    result = funcNode;    if (negate)    {      location = new LocationImpl(notToken, m_path, m_offset_line, m_offset_column);      funcNode = new GeneralFunctionNode(NotFunction.NAME, location);      funcNode.addArgument(result);      result = funcNode;    }    return result;  }}ValueExpression null_predicate(ValueExpression left) throws QueryParsingException :{  ValueExpression result = left;  boolean negate = false;  Token isToken, notToken = null;  Location location;}{  isToken = < K_IS >  [    notToken = < K_NOT >    {      negate = true;    }  ]  < K_NULL >  {    location = new LocationImpl(isToken, m_path, m_offset_line, m_offset_column);    GeneralFunctionNode funcNode = new GeneralFunctionNode(IsNullFunction.NAME, location);    funcNode.addArgument(result);    result = funcNode;    if (negate)    {      location = new LocationImpl(notToken, m_path, m_offset_line, m_offset_column);      funcNode = new GeneralFunctionNode(NotFunction.NAME, location);      funcNode.addArgument(result);      result = funcNode;    }    return result;  }}ValueExpression exists_predicate() throws QueryParsingException :{  ValueExpression expr = null;  Token token;}{  token = < K_EXISTS > < C_LEFT_PAREN > expr = expression() < C_RIGHT_PAREN >  {    Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    return new ExistsNode(expr, location);  }}ValueExpression search_condition() throws QueryParsingException :{  ValueExpression expr;}{  expr = boolean_value_expression()  {    return expr;  }}/////////////////////////////////////////////////////////////////////
// 10 ADDITIONAL COMMON ELEMENTS
/////////////////////////////////////////////////////////////////////
ValueExpression routine_invocation() throws QueryParsingException :{  GeneralFunctionNode funcNode;  List < ValueExpression > args;  AttributeReference attrRef = null;}{  funcNode = routine_name() args = SQL_argument_list()  {    funcNode.addArguments(args);  }  [ < C_PERIOD > attrRef = identifier_chain() ]  {    if (attrRef != null)    {      attrRef.setStartingFunctionNode(funcNode);      return attrRef;    }    return funcNode;  }}GeneralFunctionNode routine_name() throws QueryParsingException :{  GeneralFunctionNode funcNode;  Token dataSource = null;  Token funcName = null;  Location location;}{  (    [      LOOKAHEAD(2)      dataSource = data_source_name() < C_PERIOD >    ]    funcName = qualified_identifier()  )  {    if (dataSource == null)    {      location = new LocationImpl(funcName, m_path, m_offset_line, m_offset_column);      funcNode = new GeneralFunctionNode(funcName.image, location);    }    else    {      location = new LocationImpl(dataSource, m_path, m_offset_line, m_offset_column);      funcNode = new ExternalFunctionNode(funcName.image, dataSource.image, location);    }    return funcNode;  }}List < ValueExpression > SQL_argument_list() throws QueryParsingException :{  List < ValueExpression > args = new ArrayList < ValueExpression > ();  ValueExpression arg;}{  < C_LEFT_PAREN >  [    arg = SQL_argument()    {      args.add(arg);    }    (      < C_COMMA > arg = SQL_argument()      {        args.add(arg);      }    )*  ]  < C_RIGHT_PAREN >  {    return args;  }}ValueExpression SQL_argument() throws QueryParsingException :{  ValueExpression expr;}{  expr = value_expression()  {    return expr;  }}AggregateFunctionNode aggregate_function() throws QueryParsingException :{  AggregateFunctionNode function;  Token token = null;}{  LOOKAHEAD(4) // To differentiate between COUNT(*) and other COUNT calls
  token = < K_COUNT > < C_LEFT_PAREN > < C_ASTERISK > < C_RIGHT_PAREN >  {    Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    AggregateFunctionNode funcNode = new AggregateFunctionNode(AggregateFunctionNode.AggregateType.COUNT, location);    return funcNode;  }| function = general_set_function()  {    return function;  }}AggregateFunctionNode general_set_function() throws QueryParsingException :{  AggregateFunctionNode funcNode;  SetQuantifier setQuantifier = SetQuantifier.ALL;  List < ValueExpression > args = new ArrayList < ValueExpression > ();  ValueExpression arg;}{  funcNode = set_function_type() < C_LEFT_PAREN > [ setQuantifier = set_quantifier() ] arg = SQL_argument()  {    args.add(arg);  }  (    < C_COMMA > arg = SQL_argument()    {      args.add(arg);    }  )*  < C_RIGHT_PAREN >  {    funcNode.setSetQuantifier(setQuantifier);    funcNode.addArguments(args);    return funcNode;  }}AggregateFunctionNode set_function_type() throws QueryParsingException :{  Token token = null;  AggregateFunctionNode.AggregateType aggType = null;}{  (    token = < K_AVG >    {      aggType = AggregateFunctionNode.AggregateType.AVG;    }  | token = < K_COUNT >    {      aggType = AggregateFunctionNode.AggregateType.COUNT;    }  | token = < K_MAX >    {      aggType = AggregateFunctionNode.AggregateType.MAX;    }  | token = < K_MIN >    {      aggType = AggregateFunctionNode.AggregateType.MIN;    }  | token = < K_SUM >    {      aggType = AggregateFunctionNode.AggregateType.SUM;    }  | token = < K_NEST >    {      aggType = AggregateFunctionNode.AggregateType.NEST;    }  | token = < K_STRING_AGG >    {      aggType = AggregateFunctionNode.AggregateType.STRING_AGG;    }  )  {    Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    AggregateFunctionNode funcNode = new AggregateFunctionNode(aggType, location);    return funcNode;  }}SetQuantifier set_quantifier() throws QueryParsingException :{}{  < K_DISTINCT >  {    return SetQuantifier.DISTINCT;  }| < K_ALL >  {    return SetQuantifier.ALL;  }}List < OrderByItem > sort_specification_list() throws QueryParsingException :{  List < OrderByItem > orderByList = new ArrayList < OrderByItem > ();  OrderByItem orderByItem = null;}{  orderByItem = sort_specification()  {    orderByList.add(orderByItem);  }  (    < C_COMMA > orderByItem = sort_specification()    {      orderByList.add(orderByItem);    }  )*  {    return orderByList;  }}OrderByItem sort_specification() throws QueryParsingException :{  ValueExpression expr;  OrderByItem.Spec orderingSpec = null;  OrderByItem.Nulls nullOrdering = null;}{  (    expr = sort_key() [ orderingSpec = ordering_specification() ] [ nullOrdering = null_ordering() ]    {      return new OrderByItem(expr, orderingSpec, nullOrdering, expr.getLocation());    }  )}ValueExpression sort_key() throws QueryParsingException :{  ValueExpression expr;}{  expr = value_expression()  {    return expr;  }}OrderByItem.Spec ordering_specification() throws QueryParsingException :{}{  < NK_ASC >  {    return OrderByItem.Spec.ASC;  }| < NK_DESC >  {    return OrderByItem.Spec.DESC;  }}OrderByItem.Nulls null_ordering() throws QueryParsingException :{}{  < NK_NULLS >  (    < NK_FIRST >    {      return OrderByItem.Nulls.FIRST;    }  | < NK_LAST >    {      return OrderByItem.Nulls.LAST;    }  )}/////////////////////////////////////////////////////////////////////
// 11 SCHEMA DEFINITION AND MANIPULATION
/////////////////////////////////////////////////////////////////////
CreateStatement data_object_definition() throws QueryParsingException :{  CreateStatement statement = null;  AttributeReference name;  Type rootType;  Token token;}{  token = < K_CREATE > < K_DATA > < K_OBJECT > name = data_object_name()  {    Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    statement = new CreateStatement(name.getPathSteps().get(1), name.getPathSteps().get(0), location);  }  rootType = column_definition_type(null, null, null, statement)  {    statement.setSchemaTree(new SchemaTree(rootType));    return statement;  }}CollectionType collection_definition(String attrName, TupleType tupleType, CreateStatement createStatement) throws QueryParsingException :{  CollectionType collectionType = new CollectionType();  if (tupleType != null)  {    tupleType.setAttribute(attrName, collectionType);  }}{  < K_COLLECTION > < C_LEFT_PAREN > collection_definition_element(collectionType, createStatement)  (    < C_COMMA > collection_definition_element(collectionType, createStatement)  )*  < C_RIGHT_PAREN >  {    return collectionType;  }}void collection_definition_element(CollectionType collectionType, CreateStatement createStatement) throws QueryParsingException :{  TupleType tupleType = collectionType.getTupleType();}{  (    column_definition(tupleType, collectionType, createStatement)  | table_constraint_definition(collectionType)  )}TupleType tuple_definition(String attrName, TupleType tupleType, TupleType newTupleType, CollectionType closestCollectionType, CreateStatement createStatement) throws QueryParsingException :{  if (tupleType != null)  {    tupleType.setAttribute(attrName, newTupleType);  }}{  < K_TUPLE > < C_LEFT_PAREN >  [    tuple_definition_element(newTupleType, closestCollectionType, createStatement)    (      < C_COMMA > tuple_definition_element(newTupleType, closestCollectionType, createStatement)    )*  ]  < C_RIGHT_PAREN >  {    return newTupleType;  }}void tuple_definition_element(TupleType tupleType, CollectionType closestCollectionType, CreateStatement createStatement) throws QueryParsingException :{}{  column_definition(tupleType, closestCollectionType, createStatement)}SwitchType switch_definition(String attrName, TupleType tupleType, CollectionType closestCollectionType, CreateStatement createStatement) throws QueryParsingException :{  SwitchType switchType = new SwitchType();  if (tupleType != null)  {    tupleType.setAttribute(attrName, switchType);  }}{  < K_SWITCH > < C_LEFT_PAREN > switch_definition_element(switchType, closestCollectionType, createStatement)  (    < C_COMMA > switch_definition_element(switchType, closestCollectionType, createStatement)  )*  < C_RIGHT_PAREN >  {    return switchType;  }}void switch_definition_element(SwitchType switchType, CollectionType closestCollectionType, CreateStatement createStatement) throws QueryParsingException :{  Token name;  TupleType tupleType = new TupleType();}{  (    name = identifier()    {      switchType.setCase(name.image, tupleType);    }    tuple_definition(null, null, tupleType, closestCollectionType, createStatement)  )}DropStatement drop_data_object_statement() throws QueryParsingException :{  DropStatement statement = null;  AttributeReference name;  Token token;}{  token = < K_DROP > < K_DATA > < K_OBJECT > name = data_object_name()  {    Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    statement = new DropStatement(name.getPathSteps().get(1), name.getPathSteps().get(0), location);    return statement;  }}Type column_definition(TupleType tupleType, CollectionType collectionType, CreateStatement createStatement) throws QueryParsingException :{  Token name;  Type type;}{  name = column_name() type = column_definition_type(name.image, tupleType, collectionType, createStatement)  {    return type;  }}Type column_definition_type(String attrName, TupleType tupleType, CollectionType closestCollectionType, CreateStatement createStatement) throws QueryParsingException :{  Type type;}{  type = column_definition_data_type(attrName, tupleType, closestCollectionType, createStatement)  {    return type;  }}Type column_definition_data_type(String attrName, TupleType tupleType, CollectionType closestCollectionType, CreateStatement createStatement) throws QueryParsingException :{  Type type;  Type old_type;}{  type = data_type(attrName, tupleType, closestCollectionType, createStatement)  {    old_type = type;    type = TypeUtil.cloneNoParent(type);    if (createStatement != null) createStatement.updateType(old_type, type);    if (tupleType != null)    {      tupleType.setAttribute(attrName, type);    }  }  [ default_clause(type, createStatement) ]  (    column_constraint_definition(type, closestCollectionType)  )*  {    return type;  }}void column_constraint_definition(Type type, CollectionType closestCollectionType) throws QueryParsingException :{}{  column_constraint(type, closestCollectionType)}void column_constraint(Type type, CollectionType closestCollectionType) throws QueryParsingException :{  Constraint constraint = null;}{  (    < K_NOT > < K_NULL >    {      constraint = new NonNullConstraint(type);    }  | unique_specification()    {      // Get the closest ancestor collection type, if there is one
      if (closestCollectionType != null)      {        new LocalPrimaryKeyConstraint(closestCollectionType, Collections.singletonList(type));      }    }  )}void default_clause(Type type, CreateStatement createStatement) throws QueryParsingException :{}{  < K_DEFAULT > default_option(type, createStatement)}void default_option(Type type, CreateStatement createStatement) throws QueryParsingException :{  ValueExpression expression = null;}{  expression = value_expression()  {    if (createStatement == null) throw new QueryParsingException(QueryParsing.DEFAULT_VALUE_NOT_SUPPORTED, expression.getLocation());    createStatement.addDefaultExpression(type, expression);  }}void table_constraint_definition(CollectionType collectionType) throws QueryParsingException :{}{  table_constraint(collectionType)}void table_constraint(CollectionType collectionType) throws QueryParsingException :{}{  unique_constraint_definition(collectionType)}void unique_constraint_definition(CollectionType collectionType) throws QueryParsingException :{  List < Type > uniqueColumnList;}{  unique_specification() < C_LEFT_PAREN > uniqueColumnList = unique_column_list(collectionType) < C_RIGHT_PAREN >  {    new LocalPrimaryKeyConstraint(collectionType, uniqueColumnList);  }}void unique_specification() throws QueryParsingException :{}{  < K_PRIMARY > < K_KEY >}List < Type > unique_column_list(CollectionType collectionType) throws QueryParsingException :{  AttributeReference attrRef;  Type type;  List < Type > uniqueColumnList = new ArrayList < Type > ();}{  attrRef = identifier_chain()  {    type = new SchemaPath(attrRef.getPathSteps(), PathMode.RELATIVE).find(collectionType.getTupleType());    assert (type != null) : "No type can be found in path: " + attrRef.toString();    assert (type instanceof ScalarType) : "No scalar type found in path: " + attrRef.toString();    uniqueColumnList.add((ScalarType) type);  }  (    < C_COMMA > attrRef = identifier_chain()    {      type = new SchemaPath(attrRef.getPathSteps(), PathMode.RELATIVE).find(collectionType.getTupleType());      assert (type != null) : "No type can be found in path: " + attrRef.toString();      assert (type instanceof ScalarType) : "No scalar type found in path: " + attrRef.toString();      uniqueColumnList.add((ScalarType) type);    }  )*  {    return uniqueColumnList;  }}/////////////////////////////////////////////////////////////////////
// 13 SQL-CLIENT MODULES
/////////////////////////////////////////////////////////////////////
DdlStatement SQL_schema_statement() throws QueryParsingException :{  DdlStatement statement = null;}{  (    statement = SQL_schema_definition_statement()  | statement = SQL_schema_manipulation_statement()  )  {    return statement;  }}DdlStatement SQL_schema_definition_statement() throws QueryParsingException :{  DdlStatement statement = null;}{  statement = data_object_definition()  {    return statement;  }}DdlStatement SQL_schema_manipulation_statement() throws QueryParsingException :{  DdlStatement statement = null;}{  statement = drop_data_object_statement()  {    return statement;  }}/////////////////////////////////////////////////////////////////////
// 14 DATA MANIPULATION 
/////////////////////////////////////////////////////////////////////
DmlStatement dml_statement() throws QueryParsingException :{  DmlStatement statement = null;}{  (    statement = delete_statement_searched()  | statement = insert_statement()  | statement = update_statement_searched()  | statement = access_statement()  )  {    return statement;  }}AttributeReference target_table() throws QueryParsingException :{  AttributeReference target = null;}{  target = identifier_chain()  {    return target;  }}DeleteStatement delete_statement_searched() throws QueryParsingException :{  AttributeReference target = null;  ValueExpression condition = null;  DeleteStatement statement;  Token alias, token;}{  token = < K_DELETE > < K_FROM > target = target_table()  {    Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    statement = new DeleteStatement(location);    statement.setTarget(target);  }  [    [ < K_AS > ] alias = correlation_name()    {      statement.setAlias(alias.image);    }  ]  [    < K_WHERE > condition = search_condition()    {      statement.setCondition(condition);    }  ]  {    return statement;  }}InsertStatement insert_statement() throws QueryParsingException :{  List < String > columnList = null;  AttributeReference target = null;  ValueExpression valueExpression = null;  List < ValueExpression > expressions = null;  InsertStatement statement = null;  Token token;}{  token = < K_INSERT > < K_INTO > target = target_table()  {    Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    statement = new InsertStatement(target, location);  }  (    < K_DEFAULT > < K_VALUES >    {      statement.setDefaultValues(true);    }  |    [      LOOKAHEAD(2)      columnList = insert_column_list()      {        statement.setTargetAttributes(columnList);      }    ]    (      valueExpression = expression()      {        statement.setValueExpression(valueExpression);      }    | expressions = contextually_typed_table_value_constructor()      {        statement.setValueConstructors(expressions);      }    )  )  {    return statement;  }}List < String > insert_column_list() throws QueryParsingException :{  List < String > columnList = null;}{  < C_LEFT_PAREN > columnList = column_name_list() < C_RIGHT_PAREN >  {    return columnList;  }}UpdateStatement update_statement_searched() throws QueryParsingException :{  UpdateStatement statement;  AttributeReference target = null;  ValueExpression condition = null;  List < Pair < AttributeReference, ValueExpression >> setList = null;  Pair < AttributeReference, ValueExpression > setItem = null;  Token alias, token;  Location location;}{  (    (      token = < K_UPDATE > target = target_table()      {        location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);        statement = new UpdateStatement(location);        statement.setTarget(target);      }      [        [ < K_AS > ] alias = correlation_name()        {          statement.setAlias(alias.image);        }      ]      < K_SET > setList = set_clause_list()      {        statement.setUpdateList(setList);      }      [        < K_WHERE > condition = search_condition()        {          statement.setCondition(condition);        }      ]    )  |    (      token = < K_SET > setItem = set_clause()      {        location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);        statement = new UpdateStatement(location);        setList = new ArrayList < Pair < AttributeReference, ValueExpression >> ();        setList.add(setItem);        statement.setUpdateList(setList);      }    )  )  {    return statement;  }}List < Pair < AttributeReference, ValueExpression >> set_clause_list() throws QueryParsingException :{  List < Pair < AttributeReference, ValueExpression >> list = new ArrayList < Pair < AttributeReference, ValueExpression >> ();  Pair < AttributeReference, ValueExpression > pair = null;}{  pair = set_clause()  {    list.add(pair);  }  (    < C_COMMA > pair = set_clause()    {      list.add(pair);    }  )*  {    return list;  }}Pair < AttributeReference, ValueExpression > set_clause() throws QueryParsingException :{  AttributeReference target = null;  ValueExpression value = null;}{  target = set_target() < C_EQUALS_OPERATOR > value = update_source()  {    return new Pair < AttributeReference, ValueExpression > (target, value);  }}AttributeReference set_target() throws QueryParsingException :{  AttributeReference result;}{  result = update_target()  {    return result;  }}AttributeReference update_target() throws QueryParsingException :{  AttributeReference result;}{  result = identifier_chain()  {    return result;  }}ValueExpression update_source() throws QueryParsingException :{  ValueExpression expression = null;}{  expression = value_expression()  {    return expression;  }}AccessStatement access_statement() throws QueryParsingException :{  AccessStatement statement;  DmlStatement nested_statement = null;  AttributeReference target = null;  ValueExpression condition = null;  Token alias, token;}{  token = < K_ACCESS > target = target_table()  {    Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    statement = new AccessStatement(location);    statement.setTarget(target);  }  [    [ < K_AS > ] alias = correlation_name()    {      statement.setAlias(alias.image);    }  ]  [    < K_WHERE > condition = search_condition()    {      statement.setCondition(condition);    }  ]  nested_statement = dml_statement()  {    statement.setStatement(nested_statement);    return statement;  }}/////////////////////////////////////////////////////////////////////
// 22 DIRECT INVOCATION OF SQL 
/////////////////////////////////////////////////////////////////////
QueryStatement direct_SQL_statement() throws QueryParsingException :{  QueryStatement statement = null;}{  statement = directly_executable_statement()  {    return statement;  }}QueryStatement directly_executable_statement() throws QueryParsingException :{  QueryStatement statement = null;}{  (    statement = direct_SQL_data_statement()  | statement = SQL_schema_statement()  )  {    return statement;  }}QueryStatement direct_SQL_data_statement() throws QueryParsingException :{  QueryStatement statement = null;}{  (    statement = dml_statement()  | statement = direct_select_statement_multiple_rows()  )  {    return statement;  }}ValueExpression direct_select_statement_multiple_rows() throws QueryParsingException :{  ValueExpression expr = null;}{  expr = expression()  {    return expr;  }}ValueExpression expression() throws QueryParsingException :{  ValueExpression expr = null;}{  (    LOOKAHEAD(query_expression())    expr = query_expression()  | expr = value_expression()  )  {    return expr;  }}/////////////////////////////////////////////////////////////////////
// FPL LANGUAGE
/////////////////////////////////////////////////////////////////////
List < Definition > create_action() throws FplParsingException :{  List < Definition > definitions = new ArrayList < Definition > ();  Token path, name;  ActionDefinition action;  FunctionDefinition function;  Location location;}{  token = < K_CREATE > < A_ACTION >  (    (      path = identifier()    | path = < L_DOUBLE_QUOTE_LITERAL >    )  | path = < URL_HPATH >  )  {    location = new LocationImpl(path, m_path, m_offset_line, m_offset_column);    action = new ActionDefinition(location);    action.setPath(path.image);    definitions.add(action);  }  (    < A_FUNCTION > name = identifier()    {      action.setFunctionName(name.image);    }  |    {      action.setFunctionName(path.image);      location = new LocationImpl(path, m_path, m_offset_line, m_offset_column);      function = new FunctionDefinition(location);      function.setName(path.image);      definitions.add(function);    }    create_declaration(function)  )  < C_SEMICOLON >  {    return definitions;  }}FunctionDefinition create_function() throws FplParsingException :{  FunctionDefinition function;  Token name;}{  < K_CREATE > < A_FUNCTION > name = identifier()  {    Location location = new LocationImpl(name, m_path, m_offset_line, m_offset_column);    function = new FunctionDefinition(location);    function.setName(name.image);  }  create_declaration(function)  [    < A_IMMUTABLE >    {      function.setImmutable(true);    }  ]  < C_SEMICOLON >  {    return function;  }}void create_declaration(FunctionDefinition function) throws FplParsingException :{  ParameterDeclaration declaration;  Type return_type;  DeclarationSection declare_section;  Body body;}{  < C_LEFT_PAREN >  [    declaration = parameter_declaration()    {      function.addParameterDeclaration(declaration);    }    (      < C_COMMA > declaration = parameter_declaration()      {        function.addParameterDeclaration(declaration);      }    )*  ]  < C_RIGHT_PAREN >  [    < A_RETURNS > return_type = data_type(null, null, null, null)    {      function.setReturnType(return_type);    }  ]  < K_AS >  [    declare_section = declare_section()    {      function.setDeclarationSection(declare_section);    }  ]  body = function_body()  {    function.setFunctionBody(body);  }}ParameterDeclaration parameter_declaration() throws FplParsingException :{  ParameterDeclaration declaration;  Token name;  Type type;}{  [ < K_IN > ] name = identifier() type = data_type(null, null, null, null)  {    Location location = new LocationImpl(name, m_path, m_offset_line, m_offset_column);    declaration = new ParameterDeclaration(location);    declaration.setName(name.image);    declaration.setType(type);    return declaration;  }}DeclarationSection declare_section() throws FplParsingException :{  DeclarationSection declare_section;  VariableDeclaration variable_declaration = null;  ExceptionDeclaration exception_declaration = null;  Token token;}{  token = < A_DECLARE >  {    Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    declare_section = new DeclarationSection(location);  }  (    LOOKAHEAD(2)    exception_declaration = exception_declaration()    {      declare_section.addExceptionDeclaration(exception_declaration);    }  | variable_declaration = variable_declaration()    {      declare_section.addVariableDeclaration(variable_declaration);    }  )+  {    return declare_section;  }}VariableDeclaration variable_declaration() throws FplParsingException :{  VariableDeclaration declaration;  Token name;  Type type;  ValueExpression expr;}{  name = identifier() type = data_type(null, null, null, null)  {    Location location = new LocationImpl(name, m_path, m_offset_line, m_offset_column);    declaration = new VariableDeclaration(location);    declaration.setName(name.image);    declaration.setType(type);  }  [    expr = action_default_clause()    {      declaration.setDefaultExpression(expr);    }  ]  < C_SEMICOLON >  {    return declaration;  }}ValueExpression action_default_clause() throws FplParsingException :{  ValueExpression expr;}{  (    < K_DEFAULT >  | < C_COLON > < C_EQUALS_OPERATOR >  )  expr = value_expression()  {    return expr;  }}ExceptionDeclaration exception_declaration() throws FplParsingException :{  ExceptionDeclaration declaration;  Token name;}{  name = exception_name() < A_EXCEPTION > < C_SEMICOLON >  {    Location location = new LocationImpl(name, m_path, m_offset_line, m_offset_column);    declaration = new ExceptionDeclaration(location);    declaration.setExceptionName(name.image);    return declaration;  }}Body function_body() throws FplParsingException :{  Body body;  Statement statement;  ExceptionHandler handler;  Token token;}{  token = < A_BEGIN >  {    Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    body = new Body(location);  }  (    statement = action_statement()    {      body.addStatement(statement);    }  )*  [    < A_EXCEPTION >    (      handler = exception_handler()      {        body.addExceptionHandler(handler);      }    )*  ]  < K_END >  {    return body;  }}Statement action_statement() throws FplParsingException :{  Statement statement = null;}{  (    statement = if_statement()  | statement = raise_statement()  | statement = return_statement()  | LOOKAHEAD(identifier_chain() < C_COLON > < C_EQUALS_OPERATOR >)    statement = assignment_statement()  | statement = direct_SQL_statement() < C_SEMICOLON >  | statement = action_invocation()  )  {    return statement;  }}AssignmentStatement assignment_statement() throws FplParsingException :{  AssignmentStatement statement;  ValueExpression expr;  AttributeReference target;}{  target = identifier_chain() < C_COLON > < C_EQUALS_OPERATOR > expr = expression() < C_SEMICOLON >  {    statement = new AssignmentStatement(target, expr, target.getLocation());    return statement;  }}IfStatement if_statement() throws FplParsingException :{  IfStatement statement;  Statement branch_statement;  ValueExpression expr;  Branch branch;  Token token;  Location location;}{  token = < A_IF > expr = boolean_value_expression()  {    location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    statement = new IfStatement(location);    branch = new Branch(expr, expr.getLocation());    statement.addBranch(branch);  }  < K_THEN >  (    branch_statement = action_statement()    {      branch.addStatement(branch_statement);    }  )*  (    < A_ELSIF > expr = boolean_value_expression()    {      branch = new Branch(expr, expr.getLocation());      statement.addBranch(branch);    }    < K_THEN >    (      branch_statement = action_statement()      {        branch.addStatement(branch_statement);      }    )*  )*  [    token = < K_ELSE >    {      location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);      branch = new Branch(new BooleanLiteral(true, location), location);      statement.addBranch(branch);    }    (      branch_statement = action_statement()      {        branch.addStatement(branch_statement);      }    )*  ]  < K_END > < A_IF > < C_SEMICOLON >  {    return statement;  }}RaiseStatement raise_statement() throws FplParsingException :{  RaiseStatement statement;  Token name;}{  < A_RAISE > name = exception_name() < C_SEMICOLON >  {    Location location = new LocationImpl(name, m_path, m_offset_line, m_offset_column);    statement = new RaiseStatement(location);    statement.setExceptionName(name.image);    return statement;  }}Token exception_name() throws FplParsingException :{  Token name;}{  name = identifier()  {    return name;  }}ReturnStatement return_statement() throws FplParsingException :{  ReturnStatement statement;  ValueExpression expr = null;  Token token;}{  token = < A_RETURN >  {    Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);    statement = new ReturnStatement(location);  }  [    expr = expression()    {      statement.setExpression(expr);    }  ]  < C_SEMICOLON >  {    return statement;  }}ExceptionHandler exception_handler() throws FplParsingException :{  ExceptionHandler handler;  Token name = null;  Token when;  Statement statement = null;}{  when = < K_WHEN >  {    Location location = new LocationImpl(when, m_path, m_offset_line, m_offset_column);    handler = new ExceptionHandler(location);  }  (    (      name = exception_name()      {        handler.addExceptionName(name.image);      }      (        < K_OR > name = exception_name()        {          handler.addExceptionName(name.image);        }      )*    )  | < A_OTHERS >  )  < K_THEN >  (    statement = action_statement()    {      handler.addStatement(statement);    }  )*  {    return handler;  }}ActionInvocation action_invocation() throws FplParsingException :{  ActionInvocation.HttpVerb httpVerb;  ActionInvocation.Method method = ActionInvocation.Method.SYNC;  boolean inNew = false;  ActionInvocation out;  Token token;}{  (    (      (        token = < K_GET >        {          httpVerb = ActionInvocation.HttpVerb.GET;        }      | token = < A_POST >        {          httpVerb = ActionInvocation.HttpVerb.POST;        }      )      [        < K_IN > < K_NEW >        {          inNew = true;        }      ]    )  |    (      token = < A_AJAX >      {        httpVerb = ActionInvocation.HttpVerb.AJAX;      }      [        < A_ASYNC >        {          method = ActionInvocation.Method.ASYNC;        }      | < A_SYNC >      ]    )  )  {    Location location = new LocationImpl(token, m_path, m_offset_line, m_offset_column);  }  (    out = static_action_invocation(httpVerb, method, inNew, location)  | out = dynamic_action_invocation(httpVerb, method, inNew, location)  )  {    return out;  }}StaticActionInvocation static_action_invocation(ActionInvocation.HttpVerb httpVerb, ActionInvocation.Method method, boolean inNew, Location location) throws FplParsingException :{  Token path;  List < ValueExpression > args;}{  (    path = identifier()  | path = < L_DOUBLE_QUOTE_LITERAL >  | path = < URL_HPATH >  )  args = SQL_argument_list() [ < C_SEMICOLON > ]  {    return new StaticActionInvocation(httpVerb, method, inNew, path.image, args, location);  }}DynamicActionInvocation dynamic_action_invocation(ActionInvocation.HttpVerb httpVerb, ActionInvocation.Method method, boolean inNew, Location location) throws FplParsingException :{  ValueExpression path;  List < ValueExpression > args;}{  < K_CALL > args = SQL_argument_list() < C_SEMICOLON >  {    return new DynamicActionInvocation(httpVerb, method, inNew, args.get(0), args.subList(1, args.size()), location);  }}/////////////////////////////////////////////////////////////////////
// USED BY THE NEW PAGE COMPILER
/////////////////////////////////////////////////////////////////////
List < VariableDeclaration > define_variable_declarations() throws FplParsingException :{  List < VariableDeclaration > declarations = new ArrayList < VariableDeclaration > ();  VariableDeclaration declaration;  Token name;  Type type;  ValueExpression expr;}{  declaration = define_variable_declaration()  {    declarations.add(declaration);  }  (    < C_COMMA > declaration = define_variable_declaration()    {      declarations.add(declaration);    }  )*  < EOF >  {    return declarations;  }}/**
 * This production rule is almost the same as the production rule
 * variable_declaration(). The only difference is that variable_declaration() splits
 * variable declarations by semicolons. 
 */VariableDeclaration define_variable_declaration() throws FplParsingException :{  VariableDeclaration declaration;  Token name;  Type type;  ValueExpression expr;}{  name = identifier() type = data_type(null, null, null, null)  {    Location location = new LocationImpl(name, m_path, m_offset_line, m_offset_column);    declaration = new VariableDeclaration(location);    declaration.setName(name.image);    declaration.setType(type);  }  [    expr = action_default_clause()    {      declaration.setDefaultExpression(expr);    }  ]  {    return declaration;  }}